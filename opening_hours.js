/* The big picture -- How does this library work? {{{
 * ======================================================================
 *  Constructor - entry to parsing code
 * ======================================================================
 *  Terminology:
 *
 *  Mo-Fr 10:00-11:00; Th 10:00-12:00
 *  \_____block_____/  \____block___/
 *
 *  The README refers to blocks as rules, which is more intuitive but less clear.
 *  Because of that only the README uses the term rule in that context.
 *  In all internal parts of this project, the term block is used.
 *
 *  Mo-Fr Jan 10:00-11:00
 *  \__/  \_/ \_________/
 *  selectors (left to right: weekday, month, time)
 *
 *  Logic:
 *  - Tokenize
 *  Foreach block:
 *    - Run top-level (block) parser
 *      - Which calls sub parser for specific selector types
 *        - Which produce selector functions
 * For more information see https://github.com/ypid/opening_hours.js.
 *  }}} */

(function (root, factory) {
	// constants (holidays, error correction) {{{
	// holidays {{{
	var holidays = {
		'fr': {
			'PH': { // http://fr.wikipedia.org/wiki/F%C3%AAtes_et_jours_f%C3%A9ri%C3%A9s_en_France
				"Jour de l'an"              : [  1,  1 ],
				"Vendredi saint"            : [  'easter', -2, [ 'Moselle', 'Bas-Rhin', 'Haut-Rhin', 'Guadeloupe', 'Martinique', 'Polynésie française' ] ],
				"Lundi de Pâques"           : [  'easter', 1 ],
				"Saint-Pierre-Chanel"       : [  4, 28, [ 'Wallis-et-Futuna' ] ],
				"Fête du Travail"           : [  5,  1 ],
				"Fête de la Victoire"       : [  5,  8 ],
				"Abolition de l'esclavage"  : [  5, 22, [ 'Martinique' ] ],
				"Abolition de l'esclavage"  : [  5, 27, [ 'Guadeloupe' ] ],
				"Jeudi de l'Ascension"      : [  'easter', 39 ],
				"Lundi de Pentecôte"        : [  'easter', 50 ],
				"Abolition de l'esclavage"  : [  6, 10, [ 'Guyane' ] ],
				"Fête de l'autonomie"       : [  6, 29, [ 'Polynésie française' ] ],
				"Fête nationale"            : [  7, 14 ],
				"Fête Victor Schoelcher"    : [  7, 21, [ 'Guadeloupe', 'Martinique' ] ],
				"Fête du Territoire"        : [  7, 29, [ 'Wallis-et-Futuna' ] ],
				"Assomption"                : [  8, 15 ],
				"Fête de la citoyenneté"    : [  9, 24, [ 'Nouvelle-Calédonie' ] ],
				"Toussaint"                 : [ 11,  1 ],
				"Armistice"                 : [ 11, 11 ],
				"Abolition de l'esclavage"  : [ 12, 20, [ 'Réunion' ] ],
				"Noël"                      : [ 12, 25 ],
				"Saint-Étienne "            : [ 12, 26, [ 'Moselle', 'Bas-Rhin', 'Haut-Rhin' ] ]
			}
		},
		'de': {
			'PH': { // http://de.wikipedia.org/wiki/Feiertage_in_Deutschland
				'Neujahrstag'               : [  1,  1 ], // month 1, day 1, whole Germany
				'Heilige Drei Könige'       : [  1,  6, [ 'Baden-Württemberg', 'Bayern', 'Sachsen-Anhalt'] ], // only in the specified states
				'Tag der Arbeit'            : [  5,  1 ], // whole Germany
				'Karfreitag'                : [ 'easter', -2 ], // two days before easter
				'Ostersonntag'              : [ 'easter',  0, [ 'Brandenburg'] ],
				'Ostermontag'               : [ 'easter',  1 ],
				'Christi Himmelfahrt'       : [ 'easter', 39 ],
				'Pfingstsonntag'            : [ 'easter', 49, [ 'Brandenburg'] ],
				'Pfingstmontag'             : [ 'easter', 50 ],
				'Fronleichnam'              : [ 'easter', 60, [ 'Baden-Württemberg', 'Bayern', 'Hessen', 'Nordrhein-Westfalen', 'Rheinland-Pfalz', 'Saarland' ] ],
				'Mariä Himmelfahrt'         : [  8, 15, [ 'Saarland'] ],
				'Tag der Deutschen Einheit' : [ 10,  3 ],
				'Reformationstag'           : [ 10, 31, [ 'Brandenburg', 'Mecklenburg-Vorpommern', 'Sachsen', 'Sachsen-Anhalt', 'Thüringen'] ],
				'Allerheiligen'             : [ 11,  1, [ 'Baden-Württemberg', 'Bayern', 'Nordrhein-Westfalen', 'Rheinland-Pfalz', 'Saarland' ] ],
				'1. Weihnachtstag'          : [ 12, 25 ],
				'2. Weihnachtstag'          : [ 12, 26 ],
				// 'Silvester'                 : [ 12, 31 ], // for testing
			},
			'Baden-Württemberg': { // does only apply in Baden-Württemberg
				// This more specific rule set overwrites the country wide one (they are just ignored).
				// You may use this instead of the country wide with some
				// additional holidays for some states, if one state
				// totally disagrees about how to do public holidays …
				// 'PH': {
				// 	'2. Weihnachtstag'          : [ 12, 26 ],
				// },

				// school holiday normally variate between states
				'SH': [ // generated by convert_ical_to_json
						// You may can adjust this script to use other resources (for other countries) too.
					{
						name: 'Osterferien',
						2005: [  3, 24, /* to */  3, 24,   3, 29, /* to */  4,  2 ],
						2006: [  4, 18, /* to */  4, 22 ],
						2007: [  4,  2, /* to */  4, 14 ],
						2008: [  3, 17, /* to */  3, 28 ],
						2009: [  4,  9, /* to */  4,  9,   4, 14, /* to */  4, 17 ],
						2010: [  4,  1, /* to */  4,  1,   4,  6, /* to */  4, 10 ],
						2011: [  4, 21, /* to */  4, 21,   4, 26, /* to */  4, 30 ],
						2012: [  4,  2, /* to */  4, 13 ],
						2013: [  3, 25, /* to */  4,  5 ],
						2014: [  4, 14, /* to */  4, 25 ],
						2015: [  3, 30, /* to */  4, 10 ],
						2016: [  3, 29, /* to */  4,  2 ],
						2017: [  4, 10, /* to */  4, 21 ],
					},
					{
						name: 'Pfingstferien',
						2005: [  5, 17, /* to */  5, 28 ],
						2006: [  5, 29, /* to */  6, 10 ],
						2007: [  5, 29, /* to */  6,  9 ],
						2008: [  5, 13, /* to */  5, 23 ],
						2009: [  5, 25, /* to */  6,  6 ],
						2010: [  5, 25, /* to */  6,  5 ],
						2011: [  6, 14, /* to */  6, 25 ],
						2012: [  5, 29, /* to */  6,  9 ],
						2013: [  5, 21, /* to */  6,  1 ],
						2014: [  6, 10, /* to */  6, 21 ],
						2015: [  5, 26, /* to */  6,  6 ],
						2016: [  5, 17, /* to */  5, 28 ],
						2017: [  6,  6, /* to */  6, 16 ],
					},
					{
						name: 'Sommerferien',
						2005: [  7, 28, /* to */  9, 10 ],
						2006: [  8,  3, /* to */  9, 16 ],
						2007: [  7, 26, /* to */  9,  8 ],
						2008: [  7, 24, /* to */  9,  6 ],
						2009: [  7, 30, /* to */  9, 12 ],
						2010: [  7, 29, /* to */  9, 11 ],
						2011: [  7, 28, /* to */  9, 10 ],
						2012: [  7, 26, /* to */  9,  8 ],
						2013: [  7, 25, /* to */  9,  7 ],
						2014: [  7, 31, /* to */  9, 13 ],
						2015: [  7, 30, /* to */  9, 12 ],
						2016: [  7, 28, /* to */  9, 10 ],
						2017: [  7, 27, /* to */  9,  9 ],
					},
					{
						name: 'Herbstferien',
						2005: [ 11,  2, /* to */ 11,  4 ],
						2006: [ 10, 30, /* to */ 11,  3 ],
						2007: [ 10, 29, /* to */ 11,  3 ],
						2008: [ 10, 27, /* to */ 10, 31 ],
						2009: [ 10, 26, /* to */ 10, 31 ],
						2010: [ 11,  2, /* to */ 11,  6 ],
						2011: [ 10, 31, /* to */ 10, 31,  11,  2, /* to */ 11,  4 ],
						2012: [ 10, 29, /* to */ 11,  2 ],
						2013: [ 10, 28, /* to */ 10, 30 ],
						2014: [ 10, 27, /* to */ 10, 30 ],
						2015: [ 11,  2, /* to */ 11,  6 ],
						2016: [ 11,  2, /* to */ 11,  4 ],
					},
					{
						name: 'Weihnachtsferien',
						2005: [ 12, 22, /* to */  1,  5 ],
						2006: [ 12, 27, /* to */  1,  5 ],
						2007: [ 12, 24, /* to */  1,  5 ],
						2008: [ 12, 22, /* to */  1, 10 ],
						2009: [ 12, 23, /* to */  1,  9 ],
						2010: [ 12, 23, /* to */  1,  8 ],
						2011: [ 12, 23, /* to */  1,  5 ],
						2012: [ 12, 24, /* to */  1,  5 ],
						2013: [ 12, 23, /* to */  1,  4 ],
						2014: [ 12, 22, /* to */  1,  5 ],
						2015: [ 12, 23, /* to */  1,  9 ],
						2016: [ 12, 23, /* to */  1,  7 ],
					},
				],
			},
			'Mecklenburg-Vorpommern': {
				'SH': [
					{
						name: 'Winterferien',
						2010: [  2,  6, /* to */  2, 20 ],
						2011: [  2,  7, /* to */  2, 19 ],
						2012: [  2,  6, /* to */  2, 17 ],
						2013: [  2,  4, /* to */  2, 15 ],
						2014: [  2,  3, /* to */  2, 15 ],
						2015: [  2,  2, /* to */  2, 14 ],
						2016: [  2,  1, /* to */  2, 13 ],
						2017: [  2,  6, /* to */  2, 18 ],
					},
					{
						name: 'Osterferien',
						2010: [  3, 29, /* to */  4,  7 ],
						2011: [  4, 16, /* to */  4, 27 ],
						2012: [  4,  2, /* to */  4, 11 ],
						2013: [  3, 25, /* to */  4,  3 ],
						2014: [  4, 14, /* to */  4, 23 ],
						2015: [  3, 30, /* to */  4,  8 ],
						2016: [  3, 21, /* to */  3, 30 ],
						2017: [  4, 10, /* to */  4, 19 ],
					},
					{
						name: 'Pfingstferien',
						2010: [  5, 21, /* to */  5, 22 ],
						2011: [  6, 10, /* to */  6, 14 ],
						2012: [  5, 25, /* to */  5, 29 ],
						2013: [  5, 17, /* to */  5, 21 ],
						2014: [  6,  6, /* to */  6, 10 ],
						2015: [  5, 22, /* to */  5, 26 ],
						2016: [  5, 14, /* to */  5, 17 ],
						2017: [  6,  2, /* to */  6,  6 ],
					},
					{
						name: 'Sommerferien',
						2010: [  7, 12, /* to */  8, 21 ],
						2011: [  7,  4, /* to */  8, 13 ],
						2012: [  6, 23, /* to */  8,  4 ],
						2013: [  6, 22, /* to */  8,  3 ],
						2014: [  7, 14, /* to */  8, 23 ],
						2015: [  7, 20, /* to */  8, 29 ],
						2016: [  7, 25, /* to */  9,  3 ],
						2017: [  7, 24, /* to */  9,  2 ],
					},
					{
						name: 'Herbstferien',
						2010: [ 10, 18, /* to */ 10, 23 ],
						2011: [ 10, 17, /* to */ 10, 21 ],
						2012: [ 10,  1, /* to */ 10,  5 ],
						2013: [ 10, 14, /* to */ 10, 19 ],
						2014: [ 10, 20, /* to */ 10, 25 ],
						2015: [ 10, 24, /* to */ 10, 30 ],
						2016: [ 10, 24, /* to */ 10, 28 ],
					},
					{
						name: 'Weihnachtsferien',
						2010: [ 12, 23, /* to */ 12, 31 ],
						2011: [ 12, 23, /* to */  1,  3 ],
						2012: [ 12, 21, /* to */  1,  4 ],
						2013: [ 12, 23, /* to */  1,  3 ],
						2014: [ 12, 22, /* to */  1,  2 ],
						2015: [ 12, 21, /* to */  1,  2 ],
						2016: [ 12, 22, /* to */  1,  2 ],
					},
				],
			},
			'Hessen': {
				'SH': [
					{
						name: 'Osterferien',
						2010: [  3, 29, /* to */  4, 10 ],
						2011: [  4, 18, /* to */  4, 30 ],
						2012: [  4,  2, /* to */  4, 14 ],
						2013: [  3, 25, /* to */  4,  6 ],
						2014: [  4, 14, /* to */  4, 26 ],
						2015: [  3, 30, /* to */  4, 11 ],
						2016: [  3, 29, /* to */  4,  9 ],
						2017: [  4,  3, /* to */  4, 15 ],
						2018: [  3, 26, /* to */  4,  7 ],
					},
					{
						name: 'Sommerferien',
						2010: [  7,  5, /* to */  8, 14 ],
						2011: [  6, 27, /* to */  8,  5 ],
						2012: [  7,  2, /* to */  8, 10 ],
						2013: [  7,  8, /* to */  8, 16 ],
						2014: [  7, 28, /* to */  9,  5 ],
						2015: [  7, 27, /* to */  9,  5 ],
						2016: [  7, 18, /* to */  8, 26 ],
						2017: [  7,  3, /* to */  8, 11 ],
					},
					{
						name: 'Herbstferien',
						2010: [ 10, 11, /* to */ 10, 22 ],
						2011: [ 10, 10, /* to */ 10, 22 ],
						2012: [ 10, 15, /* to */ 10, 27 ],
						2013: [ 10, 14, /* to */ 10, 26 ],
						2014: [ 10, 20, /* to */ 11,  1 ],
						2015: [ 10, 19, /* to */ 10, 31 ],
						2016: [ 10, 17, /* to */ 10, 29 ],
						2017: [ 10,  9, /* to */ 10, 21 ],
					},
					{
						name: 'Weihnachtsferien',
						2010: [ 12, 20, /* to */  1,  7 ],
						2011: [ 12, 21, /* to */  1,  6 ],
						2012: [ 12, 24, /* to */  1, 12 ],
						2013: [ 12, 23, /* to */  1, 11 ],
						2014: [ 12, 22, /* to */  1, 10 ],
						2015: [ 12, 23, /* to */  1,  9 ],
						2016: [ 12, 22, /* to */  1,  7 ],
						2017: [ 12, 24, /* to */  1, 13 ],
					},
				],
			},
			'Schleswig-Holstein': {
				'SH': [
					{
						name: 'Osterferien',
						2010: [  4,  3, /* to */  4, 17 ],
						2011: [  4, 15, /* to */  4, 30 ],
						2012: [  3, 30, /* to */  4, 13 ],
						2013: [  3, 25, /* to */  4,  9 ],
						2014: [  4, 16, /* to */  5,  2 ],
						2015: [  4,  1, /* to */  4, 17 ],
						2016: [  3, 24, /* to */  4,  9 ],
						2017: [  4,  7, /* to */  4, 21 ],
					},
					{
						name: 'Sommerferien',
						2010: [  7, 12, /* to */  8, 21 ],
						2011: [  7,  4, /* to */  8, 13 ],
						2012: [  6, 25, /* to */  8,  4 ],
						2013: [  6, 24, /* to */  8,  3 ],
						2014: [  7, 14, /* to */  8, 23 ],
						2015: [  7, 20, /* to */  8, 29 ],
						2016: [  7, 25, /* to */  9,  3 ],
						2017: [  7, 24, /* to */  9,  2 ],
					},
					{
						name: 'Pfingstferien',
						2011: [  6,  3, /* to */  6,  4 ],
						2012: [  5, 18, /* to */  5, 18 ],
						2013: [  5, 10, /* to */  5, 10 ],
						2014: [  5, 30, /* to */  5, 30 ],
						2015: [  5, 15, /* to */  5, 15 ],
						2016: [  5,  6, /* to */  5,  6 ],
						2017: [  5, 26, /* to */  5, 26 ],
					},
					{
						name: 'Herbstferien',
						2010: [ 10, 11, /* to */ 10, 23 ],
						2011: [ 10, 10, /* to */ 10, 22 ],
						2012: [ 10,  4, /* to */ 10, 19 ],
						2013: [ 10,  4, /* to */ 10, 18 ],
						2014: [ 10, 13, /* to */ 10, 25 ],
						2015: [ 10, 19, /* to */ 10, 31 ],
						2016: [ 10, 17, /* to */ 10, 29 ],
					},
					{
						name: 'Weihnachtsferien',
						2010: [ 12, 23, /* to */  1,  7 ],
						2011: [ 12, 23, /* to */  1,  6 ],
						2012: [ 12, 24, /* to */  1,  5 ],
						2013: [ 12, 23, /* to */  1,  6 ],
						2014: [ 12, 22, /* to */  1,  6 ],
						2015: [ 12, 21, /* to */  1,  6 ],
						2016: [ 12, 23, /* to */  1,  6 ],
					},
				],
			},
			'Berlin': {
				'SH': [
					{
						name: 'Winterferien',
						2010: [  2,  1, /* to */  2,  6 ],
						2011: [  1, 31, /* to */  2,  5 ],
						2012: [  1, 30, /* to */  2,  4 ],
						2013: [  2,  4, /* to */  2,  9 ],
						2014: [  2,  3, /* to */  2,  8 ],
						2015: [  2,  2, /* to */  2,  7 ],
						2016: [  2,  1, /* to */  2,  6 ],
						2017: [  1, 30, /* to */  2,  4 ],
					},
					{
						name: 'Osterferien',
						2010: [  3, 31, /* to */  4, 10 ],
						2011: [  4, 18, /* to */  4, 30 ],
						2012: [  4,  2, /* to */  4, 14,   4, 30, /* to */  4, 30 ],
						2013: [  3, 25, /* to */  4,  6 ],
						2014: [  4, 14, /* to */  4, 26,   5,  2, /* to */  5,  2 ],
						2015: [  3, 30, /* to */  4, 11 ],
						2016: [  3, 21, /* to */  4,  2 ],
						2017: [  4, 10, /* to */  4, 22 ],
					},
					{
						name: 'Pfingstferien',
						2010: [  5, 14, /* to */  5, 14,   5, 25, /* to */  5, 25 ],
						2011: [  6,  3, /* to */  6,  3 ],
						2012: [  5, 18, /* to */  5, 18 ],
						2013: [  5, 10, /* to */  5, 10,   5, 21, /* to */  5, 21 ],
						2014: [  5, 30, /* to */  5, 30 ],
						2015: [  5, 15, /* to */  5, 15 ],
						2016: [  5,  6, /* to */  5,  6,   5, 17, /* to */  5, 17 ],
						2017: [  5, 26, /* to */  5, 26 ],
					},
					{
						name: 'Sommerferien',
						2010: [  7,  7, /* to */  8, 21 ],
						2011: [  6, 29, /* to */  8, 12 ],
						2012: [  6, 20, /* to */  8,  3 ],
						2013: [  6, 19, /* to */  8,  2 ],
						2014: [  7,  9, /* to */  8, 22 ],
						2015: [  7, 15, /* to */  8, 28 ],
						2016: [  7, 20, /* to */  9,  2 ],
						2017: [  7, 19, /* to */  9,  1 ],
					},
					{
						name: 'Herbstferien',
						2010: [ 10, 11, /* to */ 10, 23 ],
						2011: [ 10,  4, /* to */ 10, 14 ],
						2012: [ 10,  1, /* to */ 10, 13 ],
						2013: [  9, 30, /* to */ 10, 12 ],
						2014: [ 10, 20, /* to */ 11,  1 ],
						2015: [ 10, 19, /* to */ 10, 31 ],
						2016: [ 10, 17, /* to */ 10, 28 ],
					},
					{
						name: 'Weihnachtsferien',
						2010: [ 12, 23, /* to */  1,  1 ],
						2011: [ 12, 23, /* to */  1,  3 ],
						2012: [ 12, 24, /* to */  1,  4 ],
						2013: [ 12, 23, /* to */  1,  3 ],
						2014: [ 12, 22, /* to */  1,  2 ],
						2015: [ 12, 23, /* to */  1,  2 ],
						2016: [ 12, 23, /* to */  1,  3 ],
					},
				],
			},
			'Saarland': {
				'SH': [
					{
						name: 'Winterferien',
						2010: [  2, 15, /* to */  2, 20 ],
						2011: [  3,  7, /* to */  3, 12 ],
						2012: [  2, 20, /* to */  2, 25 ],
						2013: [  2, 11, /* to */  2, 16 ],
						2014: [  3,  3, /* to */  3,  8 ],
						2015: [  2, 16, /* to */  2, 21 ],
					},
					{
						name: 'Osterferien',
						2010: [  3, 29, /* to */  4, 10 ],
						2011: [  4, 18, /* to */  4, 30 ],
						2012: [  4,  2, /* to */  4, 14 ],
						2013: [  3, 25, /* to */  4,  6 ],
						2014: [  4, 14, /* to */  4, 26 ],
						2015: [  3, 30, /* to */  4, 11 ],
					},
					{
						name: 'Sommerferien',
						2010: [  7,  5, /* to */  8, 14 ],
						2011: [  6, 24, /* to */  8,  6 ],
						2012: [  7,  2, /* to */  8, 14 ],
						2013: [  7,  8, /* to */  8, 17 ],
						2014: [  7, 28, /* to */  9,  6 ],
						2015: [  7, 27, /* to */  9,  4 ],
						2016: [  7, 18, /* to */  8, 26 ],
						2017: [  7,  3, /* to */  8, 14 ],
					},
					{
						name: 'Herbstferien',
						2010: [ 10, 11, /* to */ 10, 23 ],
						2011: [ 10,  4, /* to */ 10, 15 ],
						2012: [ 10, 22, /* to */ 11,  3 ],
						2013: [ 10, 21, /* to */ 11,  2 ],
						2014: [ 10, 20, /* to */ 10, 31 ],
					},
					{
						name: 'Weihnachtsferien',
						2010: [ 12, 20, /* to */  1,  1 ],
						2011: [ 12, 23, /* to */  1,  4 ],
						2012: [ 12, 24, /* to */  1,  5 ],
						2013: [ 12, 20, /* to */  1,  4 ],
						2014: [ 12, 22, /* to */  1,  7 ],
					},
				],
			},
			'Bremen': {
				'SH': [
					{
						name: 'Winterferien',
						2010: [  2,  1, /* to */  2,  2 ],
						2011: [  1, 31, /* to */  2,  1 ],
						2012: [  1, 30, /* to */  1, 31 ],
						2013: [  1, 31, /* to */  2,  1 ],
						2014: [  1, 30, /* to */  1, 31 ],
						2015: [  2,  2, /* to */  2,  3 ],
						2016: [  1, 28, /* to */  1, 29 ],
						2017: [  1, 30, /* to */  1, 31 ],
					},
					{
						name: 'Osterferien',
						2010: [  3, 19, /* to */  4,  6 ],
						2011: [  4, 16, /* to */  4, 30 ],
						2012: [  3, 26, /* to */  4, 11,   4, 30, /* to */  4, 30 ],
						2013: [  3, 16, /* to */  4,  2 ],
						2014: [  4,  3, /* to */  4, 22,   5,  2, /* to */  5,  2 ],
						2015: [  3, 25, /* to */  4, 10 ],
						2016: [  3, 18, /* to */  4,  2 ],
						2017: [  4, 10, /* to */  4, 22 ],
					},
					{
						name: 'Pfingstferien',
						2010: [  5, 14, /* to */  5, 14,   5, 25, /* to */  5, 25 ],
						2011: [  6,  3, /* to */  6,  3,   6, 14, /* to */  6, 14 ],
						2012: [  5, 18, /* to */  5, 18,   5, 29, /* to */  5, 29 ],
						2013: [  5, 10, /* to */  5, 10,   5, 21, /* to */  5, 21 ],
						2014: [  5, 30, /* to */  5, 30,   6, 10, /* to */  6, 10 ],
						2015: [  5, 15, /* to */  5, 15,   5, 26, /* to */  5, 26 ],
						2016: [  5,  6, /* to */  5,  6,   5, 17, /* to */  5, 17 ],
						2017: [  5, 26, /* to */  5, 26,   6,  6, /* to */  6,  6 ],
					},
					{
						name: 'Sommerferien',
						2010: [  6, 24, /* to */  8,  4 ],
						2011: [  7,  7, /* to */  8, 17 ],
						2012: [  7, 23, /* to */  8, 31 ],
						2013: [  6, 27, /* to */  8,  7 ],
						2014: [  7, 31, /* to */  9, 10 ],
						2015: [  7, 23, /* to */  9,  2 ],
						2016: [  6, 23, /* to */  8,  3 ],
						2017: [  6, 22, /* to */  8,  2 ],
					},
					{
						name: 'Herbstferien',
						2010: [ 10,  9, /* to */ 10, 23 ],
						2011: [ 10, 17, /* to */ 10, 29 ],
						2012: [ 10, 22, /* to */ 11,  3 ],
						2013: [ 10,  4, /* to */ 10, 18 ],
						2014: [ 10, 27, /* to */ 11,  8 ],
						2015: [ 10, 19, /* to */ 10, 31 ],
						2016: [ 10,  4, /* to */ 10, 15 ],
					},
					{
						name: 'Weihnachtsferien',
						2010: [ 12, 22, /* to */  1,  5 ],
						2011: [ 12, 23, /* to */  1,  4 ],
						2012: [ 12, 24, /* to */  1,  5 ],
						2013: [ 12, 23, /* to */  1,  3 ],
						2014: [ 12, 22, /* to */  1,  5 ],
						2015: [ 12, 23, /* to */  1,  6 ],
						2016: [ 12, 21, /* to */  1,  6 ],
					},
				],
			},
			'Bayern': {
				'SH': [
					{
						name: 'Winterferien',
						2010: [  2, 15, /* to */  2, 20 ],
						2011: [  3,  7, /* to */  3, 11 ],
						2012: [  2, 20, /* to */  2, 24 ],
						2013: [  2, 11, /* to */  2, 15 ],
						2014: [  3,  3, /* to */  3,  7 ],
						2015: [  2, 16, /* to */  2, 20 ],
						2016: [  2,  8, /* to */  2, 12 ],
						2017: [  2, 27, /* to */  3,  3 ],
					},
					{
						name: 'Osterferien',
						2010: [  3, 29, /* to */  4, 10 ],
						2011: [  4, 18, /* to */  4, 30 ],
						2012: [  4,  2, /* to */  4, 14 ],
						2013: [  3, 25, /* to */  4,  6 ],
						2014: [  4, 14, /* to */  4, 26 ],
						2015: [  3, 30, /* to */  4, 11 ],
						2016: [  3, 21, /* to */  4,  1 ],
						2017: [  4, 10, /* to */  4, 22 ],
					},
					{
						name: 'Pfingstferien',
						2010: [  5, 25, /* to */  6,  5 ],
						2011: [  6, 14, /* to */  6, 25 ],
						2012: [  5, 29, /* to */  6,  9 ],
						2013: [  5, 21, /* to */  5, 31 ],
						2014: [  6, 10, /* to */  6, 21 ],
						2015: [  5, 26, /* to */  6,  5 ],
						2016: [  5, 17, /* to */  5, 28 ],
						2017: [  6,  6, /* to */  6, 16 ],
					},
					{
						name: 'Sommerferien',
						2010: [  8,  2, /* to */  9, 13 ],
						2011: [  7, 30, /* to */  9, 12 ],
						2012: [  8,  1, /* to */  9, 12 ],
						2013: [  7, 31, /* to */  9, 11 ],
						2014: [  7, 30, /* to */  9, 15 ],
						2015: [  8,  1, /* to */  9, 14 ],
						2016: [  7, 30, /* to */  9, 12 ],
						2017: [  7, 29, /* to */  9, 11 ],
					},
					{
						name: 'Herbstferien',
						2010: [ 11,  2, /* to */ 11,  5 ],
						2011: [ 10, 31, /* to */ 11,  5 ],
						2012: [ 10, 29, /* to */ 11,  3 ],
						2013: [ 10, 28, /* to */ 10, 31 ],
						2014: [ 10, 27, /* to */ 10, 31 ],
						2015: [ 11,  2, /* to */ 11,  7 ],
						2016: [ 10, 31, /* to */ 11,  4 ],
					},
					{
						name: 'Weihnachtsferien',
						2010: [ 12, 24, /* to */  1,  7 ],
						2011: [ 12, 27, /* to */  1,  5 ],
						2012: [ 12, 24, /* to */  1,  5 ],
						2013: [ 12, 23, /* to */  1,  4 ],
						2014: [ 12, 24, /* to */  1,  5 ],
						2015: [ 12, 24, /* to */  1,  5 ],
						2016: [ 12, 24, /* to */  1,  5 ],
					},
				],
			},
			'Niedersachsen': {
				'SH': [
					{
						name: 'Winterferien',
						2010: [  2,  1, /* to */  2,  2 ],
						2011: [  1, 31, /* to */  2,  1 ],
						2012: [  1, 30, /* to */  1, 31 ],
						2013: [  1, 31, /* to */  2,  1 ],
						2014: [  1, 30, /* to */  1, 31 ],
						2015: [  2,  2, /* to */  2,  3 ],
						2016: [  1, 28, /* to */  1, 29 ],
						2017: [  1, 30, /* to */  1, 31 ],
					},
					{
						name: 'Osterferien',
						2010: [  3, 19, /* to */  4,  6 ],
						2011: [  4, 16, /* to */  4, 30 ],
						2012: [  3, 26, /* to */  4, 11,   4, 30, /* to */  4, 30 ],
						2013: [  3, 16, /* to */  4,  2 ],
						2014: [  4,  3, /* to */  4, 22,   5,  2, /* to */  5,  2 ],
						2015: [  3, 25, /* to */  4, 10 ],
						2016: [  3, 18, /* to */  4,  2 ],
						2017: [  4, 10, /* to */  4, 22 ],
					},
					{
						name: 'Pfingstferien',
						2010: [  5, 14, /* to */  5, 14,   5, 25, /* to */  5, 25 ],
						2011: [  6,  3, /* to */  6,  3,   6, 14, /* to */  6, 14 ],
						2012: [  5, 18, /* to */  5, 18,   5, 29, /* to */  5, 29 ],
						2013: [  5, 10, /* to */  5, 10,   5, 21, /* to */  5, 21 ],
						2014: [  5, 30, /* to */  5, 30,   6, 10, /* to */  6, 10 ],
						2015: [  5, 15, /* to */  5, 15,   5, 26, /* to */  5, 26 ],
						2016: [  5,  6, /* to */  5,  6,   5, 17, /* to */  5, 17 ],
						2017: [  5, 26, /* to */  5, 26,   6,  6, /* to */  6,  6 ],
					},
					{
						name: 'Sommerferien',
						2010: [  6, 24, /* to */  8,  4 ],
						2011: [  7,  7, /* to */  8, 17 ],
						2012: [  7, 23, /* to */  8, 31 ],
						2013: [  6, 27, /* to */  8,  7 ],
						2014: [  7, 31, /* to */  9, 10 ],
						2015: [  7, 23, /* to */  9,  2 ],
						2016: [  6, 23, /* to */  8,  3 ],
						2017: [  6, 22, /* to */  8,  2 ],
					},
					{
						name: 'Herbstferien',
						2010: [ 10,  9, /* to */ 10, 23 ],
						2011: [ 10, 17, /* to */ 10, 29 ],
						2012: [ 10, 22, /* to */ 11,  3 ],
						2013: [ 10,  4, /* to */ 10, 18 ],
						2014: [ 10, 27, /* to */ 11,  8 ],
						2015: [ 10, 19, /* to */ 10, 31 ],
						2016: [ 10,  4, /* to */ 10, 15 ],
					},
					{
						name: 'Weihnachtsferien',
						2010: [ 12, 22, /* to */  1,  5 ],
						2011: [ 12, 23, /* to */  1,  4 ],
						2012: [ 12, 24, /* to */  1,  5 ],
						2013: [ 12, 23, /* to */  1,  3 ],
						2014: [ 12, 22, /* to */  1,  5 ],
						2015: [ 12, 23, /* to */  1,  6 ],
						2016: [ 12, 21, /* to */  1,  6 ],
					},
				],
			},
			'Nordrhein-Westfalen': {
				'SH': [
					{
						name: 'Osterferien',
						2010: [  3, 27, /* to */  4, 10 ],
						2011: [  4, 18, /* to */  4, 30 ],
						2012: [  4,  2, /* to */  4, 14 ],
						2013: [  3, 25, /* to */  4,  6 ],
						2014: [  4, 14, /* to */  4, 26 ],
						2015: [  3, 30, /* to */  4, 11 ],
						2016: [  3, 21, /* to */  4,  2 ],
						2017: [  4, 10, /* to */  4, 22 ],
					},
					{
						name: 'Pfingstferien',
						2010: [  5, 25, /* to */  5, 25 ],
						2012: [  5, 29, /* to */  5, 29 ],
						2013: [  5, 21, /* to */  5, 21 ],
						2014: [  6, 10, /* to */  6, 10 ],
						2015: [  5, 26, /* to */  5, 26 ],
						2016: [  5, 17, /* to */  5, 17 ],
						2017: [  6,  6, /* to */  6,  6 ],
					},
					{
						name: 'Sommerferien',
						2010: [  7, 15, /* to */  8, 27 ],
						2011: [  7, 25, /* to */  9,  6 ],
						2012: [  7,  9, /* to */  8, 21 ],
						2013: [  7, 22, /* to */  9,  3 ],
						2014: [  7,  7, /* to */  8, 19 ],
						2015: [  6, 29, /* to */  8, 11 ],
						2016: [  7, 11, /* to */  8, 23 ],
						2017: [  7, 17, /* to */  8, 29 ],
					},
					{
						name: 'Herbstferien',
						2010: [ 10, 11, /* to */ 10, 23 ],
						2011: [ 10, 24, /* to */ 11,  5 ],
						2012: [ 10,  8, /* to */ 10, 20 ],
						2013: [ 10, 21, /* to */ 11,  2 ],
						2014: [ 10,  6, /* to */ 10, 18 ],
						2015: [ 10,  5, /* to */ 10, 17 ],
						2016: [ 10, 10, /* to */ 10, 21 ],
					},
					{
						name: 'Weihnachtsferien',
						2010: [ 12, 24, /* to */  1,  8 ],
						2011: [ 12, 23, /* to */  1,  6 ],
						2012: [ 12, 21, /* to */  1,  4 ],
						2013: [ 12, 23, /* to */  1,  7 ],
						2014: [ 12, 22, /* to */  1,  6 ],
						2015: [ 12, 23, /* to */  1,  6 ],
						2016: [ 12, 23, /* to */  1,  6 ],
					},
				],
			},
			'Sachsen': {
				'SH': [
					{
						name: 'Winterferien',
						2010: [  2,  8, /* to */  2, 20 ],
						2011: [  2, 12, /* to */  2, 26 ],
						2012: [  2, 13, /* to */  2, 25 ],
						2013: [  2,  4, /* to */  2, 15 ],
						2014: [  2, 17, /* to */  3,  1 ],
						2015: [  2,  9, /* to */  2, 21 ],
						2016: [  2,  8, /* to */  2, 20 ],
						2017: [  2, 13, /* to */  2, 24 ],
					},
					{
						name: 'Osterferien',
						2010: [  4,  1, /* to */  4, 10 ],
						2011: [  4, 22, /* to */  4, 30 ],
						2012: [  4,  6, /* to */  4, 14 ],
						2013: [  3, 29, /* to */  4,  6 ],
						2014: [  4, 18, /* to */  4, 26 ],
						2015: [  4,  2, /* to */  4, 11 ],
						2016: [  3, 25, /* to */  4,  2 ],
						2017: [  4, 13, /* to */  4, 22 ],
					},
					{
						name: 'Pfingstferien',
						2010: [  5, 14, /* to */  5, 14 ],
						2011: [  6,  3, /* to */  6,  3 ],
						2012: [  5, 18, /* to */  5, 18 ],
						2013: [  5, 10, /* to */  5, 10,   5, 18, /* to */  5, 22 ],
						2014: [  5, 30, /* to */  5, 30 ],
						2015: [  5, 15, /* to */  5, 15 ],
						2016: [  5,  6, /* to */  5,  6 ],
						2017: [  5, 26, /* to */  5, 26 ],
					},
					{
						name: 'Sommerferien',
						2010: [  6, 28, /* to */  8,  6 ],
						2011: [  7, 11, /* to */  8, 19 ],
						2012: [  7, 23, /* to */  8, 31 ],
						2013: [  7, 15, /* to */  8, 23 ],
						2014: [  7, 21, /* to */  8, 29 ],
						2015: [  7, 13, /* to */  8, 21 ],
						2016: [  6, 27, /* to */  8,  5 ],
						2017: [  6, 26, /* to */  8,  4 ],
					},
					{
						name: 'Herbstferien',
						2010: [ 10,  4, /* to */ 10, 16 ],
						2011: [ 10, 17, /* to */ 10, 28 ],
						2012: [ 10, 22, /* to */ 11,  2 ],
						2013: [ 10, 21, /* to */ 11,  1 ],
						2014: [ 10, 20, /* to */ 10, 31 ],
						2015: [ 10, 12, /* to */ 10, 24 ],
						2016: [ 10,  3, /* to */ 10, 15 ],
					},
					{
						name: 'Weihnachtsferien',
						2010: [ 12, 23, /* to */  1,  1 ],
						2011: [ 12, 23, /* to */  1,  2 ],
						2012: [ 12, 22, /* to */  1,  2 ],
						2013: [ 12, 21, /* to */  1,  3 ],
						2014: [ 12, 22, /* to */  1,  3 ],
						2015: [ 12, 21, /* to */  1,  2 ],
						2016: [ 12, 23, /* to */  1,  2 ],
					},
				],
			},
			'Thüringen': {
				'SH': [
					{
						name: 'Winterferien',
						2010: [  2,  1, /* to */  2,  6 ],
						2011: [  1, 31, /* to */  2,  5 ],
						2012: [  2,  6, /* to */  2, 11 ],
						2013: [  2, 18, /* to */  2, 23 ],
						2014: [  2, 17, /* to */  2, 22 ],
						2015: [  2,  2, /* to */  2,  7 ],
						2016: [  2,  1, /* to */  2,  6 ],
						2017: [  2,  6, /* to */  2, 11 ],
					},
					{
						name: 'Osterferien',
						2010: [  3, 29, /* to */  4,  9 ],
						2011: [  4, 18, /* to */  4, 30 ],
						2012: [  4,  2, /* to */  4, 13 ],
						2013: [  3, 25, /* to */  4,  6 ],
						2014: [  4, 19, /* to */  5,  2 ],
						2015: [  3, 30, /* to */  4, 11 ],
						2016: [  3, 24, /* to */  4,  2 ],
						2017: [  4, 10, /* to */  4, 21 ],
					},
					{
						name: 'Sommerferien',
						2010: [  6, 24, /* to */  8,  4 ],
						2011: [  7, 11, /* to */  8, 19 ],
						2012: [  7, 23, /* to */  8, 31 ],
						2013: [  7, 15, /* to */  8, 23 ],
						2014: [  7, 21, /* to */  8, 29 ],
						2015: [  7, 13, /* to */  8, 21 ],
						2016: [  6, 27, /* to */  8, 10 ],
						2017: [  6, 26, /* to */  8,  9 ],
					},
					{
						name: 'Pfingstferien',
						2011: [  6, 11, /* to */  6, 14 ],
						2012: [  5, 25, /* to */  5, 29 ],
						2013: [  5, 10, /* to */  5, 10 ],
						2014: [  5, 30, /* to */  5, 30 ],
						2015: [  5, 15, /* to */  5, 15 ],
						2016: [  5,  6, /* to */  5,  6 ],
						2017: [  5, 26, /* to */  5, 26 ],
					},
					{
						name: 'Herbstferien',
						2010: [ 10,  9, /* to */ 10, 23 ],
						2011: [ 10, 17, /* to */ 10, 28 ],
						2012: [ 10, 22, /* to */ 11,  3 ],
						2013: [ 10, 21, /* to */ 11,  2 ],
						2014: [ 10,  6, /* to */ 10, 18 ],
						2015: [ 10,  5, /* to */ 10, 17 ],
						2016: [ 10, 10, /* to */ 10, 22 ],
					},
					{
						name: 'Weihnachtsferien',
						2010: [ 12, 23, /* to */  1,  1 ],
						2011: [ 12, 23, /* to */  1,  1 ],
						2012: [ 12, 24, /* to */  1,  5 ],
						2013: [ 12, 23, /* to */  1,  4 ],
						2014: [ 12, 22, /* to */  1,  3 ],
						2015: [ 12, 23, /* to */  1,  2 ],
						2016: [ 12, 23, /* to */ 12, 31 ],
					},
				],
			},
			'Hamburg': {
				'SH': [
					{
						name: 'Winterferien',
						2010: [  1, 29, /* to */  1, 29 ],
						2011: [  1, 31, /* to */  1, 31 ],
						2012: [  1, 30, /* to */  1, 30 ],
						2013: [  2,  1, /* to */  2,  1 ],
						2014: [  1, 31, /* to */  1, 31 ],
						2015: [  1, 30, /* to */  1, 30 ],
						2016: [  1, 29, /* to */  1, 29 ],
						2017: [  1, 30, /* to */  1, 30 ],
					},
					{
						name: 'Osterferien',
						2010: [  3,  8, /* to */  3, 20 ],
						2011: [  3,  7, /* to */  3, 18 ],
						2012: [  3,  5, /* to */  3, 16 ],
						2013: [  3,  4, /* to */  3, 15 ],
						2014: [  3,  3, /* to */  3, 14 ],
						2015: [  3,  2, /* to */  3, 13 ],
						2016: [  3,  7, /* to */  3, 18 ],
						2017: [  3,  6, /* to */  3, 17 ],
					},
					{
						name: 'Pfingstferien',
						2010: [  5, 14, /* to */  5, 22 ],
						2011: [  4, 26, /* to */  4, 29,   6,  3, /* to */  6,  3 ],
						2012: [  4, 30, /* to */  5,  4,   5, 18, /* to */  5, 18 ],
						2013: [  5,  2, /* to */  5, 10 ],
						2014: [  4, 28, /* to */  5,  2,   5, 30, /* to */  5, 30 ],
						2015: [  5, 11, /* to */  5, 15 ],
						2016: [  5,  6, /* to */  5,  6,   5, 17, /* to */  5, 20 ],
						2017: [  5, 22, /* to */  5, 26 ],
					},
					{
						name: 'Sommerferien',
						2010: [  7,  8, /* to */  8, 18 ],
						2011: [  6, 30, /* to */  8, 10 ],
						2012: [  6, 21, /* to */  8,  1 ],
						2013: [  6, 20, /* to */  7, 31 ],
						2014: [  7, 10, /* to */  8, 20 ],
						2015: [  7, 16, /* to */  8, 26 ],
						2016: [  7, 21, /* to */  8, 31 ],
						2017: [  7, 20, /* to */  8, 30 ],
					},
					{
						name: 'Herbstferien',
						2010: [ 10,  4, /* to */ 10, 15 ],
						2011: [ 10,  4, /* to */ 10, 14 ],
						2012: [ 10,  1, /* to */ 10, 12 ],
						2013: [  9, 30, /* to */ 10, 11 ],
						2014: [ 10, 13, /* to */ 10, 24 ],
						2015: [ 10, 19, /* to */ 10, 30 ],
						2016: [ 10, 17, /* to */ 10, 28 ],
					},
					{
						name: 'Weihnachtsferien',
						2010: [ 12, 23, /* to */  1,  3 ],
						2011: [ 12, 27, /* to */  1,  6 ],
						2012: [ 12, 21, /* to */  1,  4 ],
						2013: [ 12, 19, /* to */  1,  3 ],
						2014: [ 12, 22, /* to */  1,  6 ],
						2015: [ 12, 21, /* to */  1,  1 ],
						2016: [ 12, 27, /* to */  1,  6 ],
					},
				],
			},
			'Sachsen-Anhalt': {
				'SH': [
					{
						name: 'Winterferien',
						2010: [  2,  8, /* to */  2, 13 ],
						2011: [  2,  5, /* to */  2, 12 ],
						2012: [  2,  4, /* to */  2, 11 ],
						2013: [  2,  1, /* to */  2,  8 ],
						2014: [  2,  1, /* to */  2, 12 ],
						2015: [  2,  2, /* to */  2, 14 ],
						2016: [  2,  1, /* to */  2, 10 ],
						2017: [  2,  4, /* to */  2, 11 ],
					},
					{
						name: 'Osterferien',
						2010: [  3, 29, /* to */  4,  9 ],
						2011: [  4, 18, /* to */  4, 27 ],
						2012: [  4,  2, /* to */  4,  7 ],
						2013: [  3, 25, /* to */  3, 30 ],
						2014: [  4, 14, /* to */  4, 17 ],
						2015: [  4,  2, /* to */  4,  2 ],
						2016: [  3, 24, /* to */  3, 24 ],
						2017: [  4, 10, /* to */  4, 13 ],
					},
					{
						name: 'Pfingstferien',
						2010: [  5, 14, /* to */  5, 22 ],
						2011: [  6, 14, /* to */  6, 18 ],
						2012: [  5, 18, /* to */  5, 25 ],
						2013: [  5, 10, /* to */  5, 18 ],
						2014: [  5, 30, /* to */  6,  7 ],
						2015: [  5, 15, /* to */  5, 23 ],
						2016: [  5,  6, /* to */  5, 14 ],
						2017: [  5, 26, /* to */  5, 26 ],
					},
					{
						name: 'Sommerferien',
						2010: [  6, 24, /* to */  8,  4 ],
						2011: [  7, 11, /* to */  8, 24 ],
						2012: [  7, 23, /* to */  9,  5 ],
						2013: [  7, 15, /* to */  8, 28 ],
						2014: [  7, 21, /* to */  9,  3 ],
						2015: [  7, 13, /* to */  8, 26 ],
						2016: [  6, 27, /* to */  8, 10 ],
						2017: [  6, 26, /* to */  8,  9 ],
					},
					{
						name: 'Herbstferien',
						2010: [ 10, 18, /* to */ 10, 23 ],
						2011: [ 10, 17, /* to */ 10, 22 ],
						2012: [ 10, 29, /* to */ 11,  2 ],
						2013: [ 10, 21, /* to */ 10, 25 ],
						2014: [ 10, 27, /* to */ 10, 30 ],
						2015: [ 10, 17, /* to */ 10, 24 ],
						2016: [ 10,  4, /* to */ 10, 15 ],
					},
					{
						name: 'Weihnachtsferien',
						2010: [ 12, 22, /* to */  1,  5 ],
						2011: [ 12, 22, /* to */  1,  7 ],
						2012: [ 12, 19, /* to */  1,  4 ],
						2013: [ 12, 21, /* to */  1,  3 ],
						2014: [ 12, 22, /* to */  1,  5 ],
						2015: [ 12, 21, /* to */  1,  5 ],
						2016: [ 12, 19, /* to */  1,  2 ],
					},
				],
			},
			'Rheinland-Pfalz': {
				'SH': [
					{
						name: 'Osterferien',
						2010: [  3, 26, /* to */  4,  9 ],
						2011: [  4, 18, /* to */  4, 29 ],
						2012: [  3, 29, /* to */  4, 13 ],
						2013: [  3, 20, /* to */  4,  5 ],
						2014: [  4, 11, /* to */  4, 25 ],
						2015: [  3, 26, /* to */  4, 10 ],
						2016: [  3, 18, /* to */  4,  1 ],
						2017: [  4, 10, /* to */  4, 21 ],
					},
					{
						name: 'Sommerferien',
						2010: [  7,  5, /* to */  8, 13 ],
						2011: [  6, 27, /* to */  8,  5 ],
						2012: [  7,  2, /* to */  8, 10 ],
						2013: [  7,  8, /* to */  8, 16 ],
						2014: [  7, 28, /* to */  9,  5 ],
						2015: [  7, 27, /* to */  9,  4 ],
						2016: [  7, 18, /* to */  8, 26 ],
						2017: [  7,  3, /* to */  8, 11 ],
					},
					{
						name: 'Herbstferien',
						2010: [ 10, 11, /* to */ 10, 22 ],
						2011: [ 10,  4, /* to */ 10, 14 ],
						2012: [ 10,  1, /* to */ 10, 12 ],
						2013: [ 10,  4, /* to */ 10, 18 ],
						2014: [ 10, 20, /* to */ 10, 31 ],
						2015: [ 10, 19, /* to */ 10, 30 ],
						2016: [ 10, 10, /* to */ 10, 21 ],
					},
					{
						name: 'Weihnachtsferien',
						2010: [ 12, 23, /* to */  1,  7 ],
						2011: [ 12, 22, /* to */  1,  6 ],
						2012: [ 12, 20, /* to */  1,  4 ],
						2013: [ 12, 23, /* to */  1,  7 ],
						2014: [ 12, 22, /* to */  1,  7 ],
						2015: [ 12, 23, /* to */  1,  8 ],
						2016: [ 12, 22, /* to */  1,  6 ],
					},
				],
			},
			'Brandenburg': {
				'SH': [
					{
						name: 'Winterferien',
						2010: [  2,  1, /* to */  2,  6 ],
						2011: [  1, 31, /* to */  2,  5 ],
						2012: [  1, 30, /* to */  2,  4 ],
						2013: [  2,  4, /* to */  2,  9 ],
						2014: [  2,  3, /* to */  2,  8 ],
						2015: [  2,  2, /* to */  2,  7 ],
						2016: [  2,  1, /* to */  2,  6 ],
						2017: [  1, 30, /* to */  2,  4 ],
					},
					{
						name: 'Osterferien',
						2010: [  3, 31, /* to */  4, 10 ],
						2011: [  4, 20, /* to */  4, 30 ],
						2012: [  4,  4, /* to */  4, 14,   4, 30, /* to */  4, 30 ],
						2013: [  3, 27, /* to */  4,  6 ],
						2014: [  4, 16, /* to */  4, 26,   5,  2, /* to */  5,  2 ],
						2015: [  4,  1, /* to */  4, 11 ],
						2016: [  3, 23, /* to */  4,  2 ],
						2017: [  4, 12, /* to */  4, 22 ],
					},
					{
						name: 'Pfingstferien',
						2010: [  5, 14, /* to */  5, 14 ],
						2011: [  6,  3, /* to */  6,  3 ],
						2012: [  5, 18, /* to */  5, 18 ],
						2013: [  5, 10, /* to */  5, 10 ],
						2014: [  5, 30, /* to */  5, 30 ],
						2015: [  5, 15, /* to */  5, 15 ],
						2016: [  5,  6, /* to */  5,  6,   5, 17, /* to */  5, 17 ],
						2017: [  5, 26, /* to */  5, 26 ],
					},
					{
						name: 'Sommerferien',
						2010: [  7,  8, /* to */  8, 21 ],
						2011: [  6, 30, /* to */  8, 13 ],
						2012: [  6, 21, /* to */  8,  3 ],
						2013: [  6, 20, /* to */  8,  2 ],
						2014: [  7, 10, /* to */  8, 22 ],
						2015: [  7, 16, /* to */  8, 28 ],
						2016: [  7, 21, /* to */  9,  3 ],
						2017: [  7, 20, /* to */  9,  1 ],
					},
					{
						name: 'Herbstferien',
						2010: [ 10, 11, /* to */ 10, 23 ],
						2011: [ 10,  4, /* to */ 10, 14 ],
						2012: [ 10,  1, /* to */ 10, 13 ],
						2013: [  9, 30, /* to */ 10, 12,  11,  1, /* to */ 11,  1 ],
						2014: [ 10, 20, /* to */ 11,  1 ],
						2015: [ 10, 19, /* to */ 10, 30 ],
						2016: [ 10, 17, /* to */ 10, 28 ],
					},
					{
						name: 'Weihnachtsferien',
						2010: [ 12, 23, /* to */  1,  1 ],
						2011: [ 12, 23, /* to */  1,  3 ],
						2012: [ 12, 24, /* to */  1,  4 ],
						2013: [ 12, 23, /* to */  1,  3 ],
						2014: [ 12, 22, /* to */  1,  2 ],
						2015: [ 12, 23, /* to */  1,  2 ],
						2016: [ 12, 23, /* to */  1,  3 ],
					},
				],
			},
		},
		'at': {
			'PH': { // http://de.wikipedia.org/wiki/Feiertage_in_%C3%96sterreich
				'Neujahrstag'               : [  1,  1 ],
				'Heilige Drei Könige'       : [  1,  6 ],
				// 'Josef'                     : [  3, 19, [ 'Kärnten', 'Steiermark', 'Tirol', 'Vorarlberg' ] ],
				// 'Karfreitag'                : [ 'easter', -2 ],
				'Ostermontag'               : [ 'easter',  1 ],
				'Staatsfeiertag'            : [  5,  1 ],
				// 'Florian'                   : [  5,  4, [ 'Oberösterreich' ] ],
				'Christi Himmelfahrt'       : [ 'easter', 39 ],
				'Pfingstmontag'             : [ 'easter', 50 ],
				'Fronleichnam'              : [ 'easter', 60 ],
				'Mariä Himmelfahrt'         : [  8, 15 ],
				// 'Rupert'                    : [  9, 24, [ 'Salzburg' ] ],
				// 'Tag der Volksabstimmung'   : [ 10, 10, [ 'Kärnten' ] ],
				'Nationalfeiertag'          : [ 10, 26 ],
				'Allerheiligen'             : [ 11,  1 ],
				// 'Martin'                    : [ 11, 11, [ 'Burgenland' ] ],
				// 'Leopold'                   : [ 11, 15, [ 'Niederösterreich', 'Wien' ] ],
				'Mariä Empfängnis'          : [ 12,  8 ],
				// 'Heiliger Abend'            : [ 12, 24 ],
				'Christtag'                 : [ 12, 25 ],
				'Stefanitag'                : [ 12, 26 ],
				// 'Silvester'                 : [ 12, 31 ],
			},
		},
		'ca': {
			'PH': { // https://en.wikipedia.org/wiki/Public_holidays_in_Canada
				"New Year's Day"            : [  1,  1 ],
				"Good Friday"               : [  'easter', -2 ],
				"Canada Day"                : [  'canadaDay', 0 ],
				"Labour Day"                : [  'firstSeptemberMonday', 0 ],
				"Christmas Day"             : [ 12, 25 ]
			},
			'Alberta': {
				'PH': {
					"New Year's Day"            : [  1,  1 ],
					"Alberta Family Day"        : [  'firstFebruaryMonday', 14 ],
					"Good Friday"               : [  'easter', -2 ],
					"Easter Monday"             : [  'easter', 1 ],
					"Victoria Day"              : [  'victoriaDay', 0 ],
					"Canada Day"                : [  'canadaDay', 0 ],
					"Heritage Day"              : [  'firstAugustMonday', 0 ],
					"Labour Day"                : [  'firstSeptemberMonday', 0 ],
					"Thanksgiving"              : [  'firstOctoberMonday', 7 ],
					"Remembrance Day"           : [ 11, 11 ],
					"Christmas Day"             : [ 12, 25 ],
					"Boxing Day"                : [ 12, 26 ]
				},
			},
			'British Columbia': {
				'PH': {
					"New Year's Day"            : [  1,  1 ],
					"Family Day"                : [  'firstFebruaryMonday', 7 ],
					"Good Friday"               : [  'easter', -2 ],
					"Victoria Day"              : [  'victoriaDay', 0 ],
					"Canada Day"                : [  'canadaDay', 0 ],
					"British Columbia Day"      : [  'firstAugustMonday', 0 ],
					"Labour Day"                : [  'firstSeptemberMonday', 0 ],
					"Thanksgiving"              : [  'firstOctoberMonday', 7 ],
					"Remembrance Day"           : [ 11, 11 ],
					"Christmas Day"             : [ 12, 25 ]
				},
			},
			'Manitoba': {
				'PH': {
					"New Year's Day"            : [  1,  1 ],
					"Louis Riel Day"            : [  'firstFebruaryMonday', 14 ],
					"Good Friday"               : [  'easter', -2 ],
					"Victoria Day"              : [  'victoriaDay', 0 ],
					"Canada Day"                : [  'canadaDay', 0 ],
					"Civic Holiday"             : [  'firstAugustMonday', 0 ],
					"Labour Day"                : [  'firstSeptemberMonday', 0 ],
					"Thanksgiving"              : [  'firstOctoberMonday', 7 ],
					"Remembrance Day"           : [ 11, 11 ],
					"Christmas Day"             : [ 12, 25 ]
				},
			},
			'New Brunswick': {
				'PH': {
					"New Year's Day"            : [  1,  1 ],
					"Good Friday"               : [  'easter', -2 ],
					"Victoria Day"              : [  'victoriaDay', 0 ],
					"Canada Day"                : [  'canadaDay', 0 ],
					"New Brunswick Day"         : [  'firstAugustMonday', 0 ],
					"Labour Day"                : [  'firstSeptemberMonday', 0 ],
					"Thanksgiving"              : [  'firstOctoberMonday', 7 ],
					"Remembrance Day"           : [ 11, 11 ],
					"Christmas Day"             : [ 12, 25 ],
					"Boxing Day"                : [ 12, 26 ]
				},
			},
			'Newfoundland and Labrador': {
				'PH': {
					"New Year's Day"            : [  1,  1 ],
					"Saint Patrick's Day"       : [  3, 17 ],
					"Good Friday"               : [  'easter', -2 ],
					"Saint George's Day"        : [  4, 23 ],
					"Discovery Day"             : [  6, 24 ],
					"Memorial Day"              : [  7, 1 ],
					"Orangemen's Day"           : [  7, 12 ],
					"Labour Day"                : [  'firstSeptemberMonday', 0 ],
					"Armistice Day"             : [ 11, 11 ],
					"Christmas Day"             : [ 12, 25 ]
				},
			},
			'Northwest Territories': {
				'PH': {
					"New Year's Day"            : [  1,  1 ],
					"Good Friday"               : [  'easter', -2 ],
					"Victoria Day"              : [  'victoriaDay', 0 ],
					"National Aboriginal Day"   : [  6, 21 ],
					"Canada Day"                : [  'canadaDay', 0 ],
					"Civic Holiday"             : [  'firstAugustMonday', 0 ],
					"Labour Day"                : [  'firstSeptemberMonday', 0 ],
					"Thanksgiving"              : [  'firstOctoberMonday', 7 ],
					"Remembrance Day"           : [ 11, 11 ],
					"Christmas Day"             : [ 12, 25 ]
				},
			},
			'Nova Scotia': {
				'PH': {
					"New Year's Day"            : [  1,  1 ],
					"Good Friday"               : [  'easter', -2 ],
					"Victoria Day"              : [  'victoriaDay', 0 ],
					"Canada Day"                : [  'canadaDay', 0 ],
					"Natal Day"                 : [  'firstAugustMonday', 0 ],
					"Labour Day"                : [  'firstSeptemberMonday', 0 ],
					"Thanksgiving"              : [  'firstOctoberMonday', 7 ],
					"Remembrance Day"           : [ 11, 11 ],
					"Christmas Day"             : [ 12, 25 ],
					"Boxing Day"                : [ 12, 26 ]
				},
			},
			'Nunavut': {
				'PH': {
					"New Year's Day"            : [  1,  1 ],
					"Good Friday"               : [  'easter', -2 ],
					"Victoria Day"              : [  'victoriaDay', 0 ],
					"Canada Day"                : [  'canadaDay', 0 ],
					"Nunavut Day"               : [  7, 9 ],
					"Civic Holiday"             : [  'firstAugustMonday', 0 ],
					"Labour Day"                : [  'firstSeptemberMonday', 0 ],
					"Thanksgiving"              : [  'firstOctoberMonday', 7 ],
					"Remembrance Day"           : [ 11, 11 ],
					"Christmas Day"             : [ 12, 25 ]
				},
			},
			'Ontario': {
				'PH': {
					"New Year's Day"              : [  1,  1 ],
					"Family Day"                  : [  'firstFebruaryMonday', 14 ],
					"Good Friday"                 : [  'easter', -2 ],
					"Victoria Day"                : [  'victoriaDay', 0 ],
					"Canada Day"                  : [  'canadaDay', 0 ],
					"August Civic Public Holiday" : [  'firstAugustMonday', 0 ],
					"Labour Day"                  : [  'firstSeptemberMonday', 0 ],
					"Thanksgiving"                : [  'firstOctoberMonday', 7 ],
					"Remembrance Day"             : [ 11, 11 ],
					"Christmas Day"               : [ 12, 25 ],
					"Boxing Day"                  : [ 12, 26 ]
				},
			},
			'Prince Edward Island': {
				'PH': {
					"New Year's Day"            : [  1,  1 ],
					"Islander Day"              : [  'firstFebruaryMonday', 14 ],
					"Good Friday"               : [  'easter', -2 ],
					"Easter Monday"             : [  'easter', 1 ],
					"Victoria Day"              : [  'victoriaDay', 0 ],
					"Canada Day"                : [  'canadaDay', 0 ],
					"Civic Holiday"             : [  'firstAugustMonday', 0 ],
					"Gold Cup Parade Day"       : [  'firstAugustMonday', 18 ],
					"Labour Day"                : [  'firstSeptemberMonday', 0 ],
					"Thanksgiving"              : [  'firstOctoberMonday', 7 ],
					"Remembrance Day"           : [ 11, 11 ],
					"Christmas Day"             : [ 12, 25 ],
					"Boxing Day"                : [ 12, 26 ]
				},
			},
			'Quebec': {
				'PH': {
					"Jour de l'an"                    : [  1,  1 ],
					"Vendredi saint"                  : [  'easter', -2 ],
					"Lundi de Pâques"                 : [  'easter', 1 ],
					"Journée nationale des patriotes" : [  'victoriaDay', 0 ],
					"Fête nationale du Québec"        : [  6, 24 ],
					"Fête du Canada"                  : [  'canadaDay', 0 ],
					"Fête du Travail"                 : [  'firstSeptemberMonday', 0 ],
					"Jour de l'Action de grâce"       : [  'firstOctoberMonday', 7 ],
					"Noël"                            : [ 12, 25 ]
				},
			},
			'Saskatchewan': {
				'PH': {
					"New Year's Day"            : [  1,  1 ],
					"Family Day"                : [  'firstFebruaryMonday', 14 ],
					"Good Friday"               : [  'easter', -2 ],
					"Victoria Day"              : [  'victoriaDay', 0 ],
					"Canada Day"                : [  'canadaDay', 0 ],
					"Saskatchewan Day"          : [  'firstAugustMonday', 0 ],
					"Labour Day"                : [  'firstSeptemberMonday', 0 ],
					"Thanksgiving"              : [  'firstOctoberMonday', 7 ],
					"Remembrance Day"           : [ 11, 11 ],
					"Christmas Day"             : [ 12, 25 ]
				},
			},
			'Yukon': {
				'PH': {
					"New Year's Day"            : [  1,  1 ],
					"Heritage Day"              : [  'lastFebruarySunday',  -2 ],
					"Good Friday"               : [  'easter', -2 ],
					"Easter Monday"             : [  'easter', 1 ],
					"Victoria Day"              : [  'victoriaDay', 0 ],
					"Canada Day"                : [  'canadaDay', 0 ],
					"Discovery Day"             : [  'firstAugustMonday', 14 ],
					"Labour Day"                : [  'firstSeptemberMonday', 0 ],
					"Thanksgiving"              : [  'firstOctoberMonday', 7 ],
					"Remembrance Day"           : [ 11, 11 ],
					"Christmas Day"             : [ 12, 25 ],
					"Boxing Day"                : [ 12, 26 ]
				},
			},
		},
		'ua': {
			'PH': { // http://uk.wikipedia.org/wiki/%D0%A1%D0%B2%D1%8F%D1%82%D0%B0_%D1%82%D0%B0_%D0%BF%D0%B0%D0%BC%27%D1%8F%D1%82%D0%BD%D1%96_%D0%B4%D0%BD%D1%96_%D0%B2_%D0%A3%D0%BA%D1%80%D0%B0%D1%97%D0%BD%D1%96
				"Новий рік"                  : [  1,  1 ],
				"Різдво"                     : [  1,  7 ],
				"Міжнародний жіночий день"   : [  3,  8 ],
				"Великдень"                  : [ 'orthodox easter',  1 ],
				"День Праці 1"               : [  5,  1 ],
				"День Праці 2"               : [  5,  2 ],
				"День Перемоги"              : [  5,  9 ],
				"День Конституції України"   : [  6, 28 ],
				"День Незалежності України"  : [  8, 24 ],
			}
		},
		'si': {
			'PH': { // http://www.vlada.si/o_sloveniji/politicni_sistem/prazniki/
				'novo leto'                                  : [  1,  1 ],
				'Prešernov dan, slovenski kulturni praznik'  : [  2,  8 ],
				'velikonočna nedelja'                        : [ 'easter',  0 ],
				'velikonočni ponedeljek'                     : [ 'easter',  1 ],
				'dan upora proti okupatorju'                 : [  4,  27 ],
				'praznik dela 1'                               : [  5, 1 ],
				'praznik dela 2'                               : [  5, 2 ],
				'binkoštna nedelja - binkošti'               : [ 'easter',  49 ],
				'dan državnosti'                             : [  6, 25 ],
				'Marijino vnebovzetje'                       : [  8, 15 ],
				'dan reformacije'                            : [ 10, 31 ],
				'dan spomina na mrtve'                       : [ 11,  1 ],
				'božič'                                      : [ 12, 25 ],
				'dan samostojnosti in enotnosti'             : [ 12, 26 ],
			},
		},
	};
	// }}}

	// error correction {{{
	// Taken form http://www.netzwolf.info/j/osm/time_domain.js
	// Credits go to Netzwolf
	//
	// Key to word_error_correction is the token name except wrong_words
	var word_error_correction = {
		wrong_words: {
			'Assuming "<ok>" for "<ko>"': {
				spring:  'Mar-May',
				summer:  'Jun-Aug',
				autumn:  'Sep-Nov',
				winter:  'Dec-Feb',
				// morning: '08:00-12:00',
				// evening: '13:00-18:00',
				'_':  '-',
				'daytime': 'sunrise-sunset',
			}, 'Bitte benutze die englische Schreibweise "<ok>" für "<ko>".': {
				sommer: 'summer',
				'werktag':  'Mo-Fr',
				'werktags': 'Mo-Fr',
			}, 'Bitte benutze "<ok>" für "<ko>". Beispiel: "Mo-Fr 08:00-12:00; Tu off"': {
				ruhetag:     'off',
				ruhetage:    'off',
				geschlossen: 'off',
				ausser:      'off',
				außer:       'off',
			}, 'Neem de engelse afkorting "<ok>" voor "<ko>" alstublieft.': {
				'gesloten':  'off',
				'feestdag':  'PH',
			}, 'Assuming "<ok>" for "<ko>". Please avoid using "workday": http://wiki.openstreetmap.org/wiki/Talk:Key:opening_hours#need_syntax_for_holidays_and_workingdays': {
				// 	// Used around 260 times but the problem is, that work day might be different in other countries.
				'wd':       'Mo-Fr',
				'weekday':  'Mo-Fr',
				'weekdays': 'Mo-Fr',
				'vardagar': 'Mo-Fr',
			}, 'Please use notation something like "Mo off" instead "<ko>".': {
				except: 'off',
			}, 'Please ommit "<ko>" or use a colon instead: "12:00-14:00".': {
				h: '',
			}, 'Please ommit "<ko>".': {
				season: '',
				hs:     '',
				hrs:    '',
				hours:  '',
			}, 'Please ommit "<ko>". The key must not be in the value.': {
				'opening_hours=': '',
			}, 'Please ommit "<ko>". You might want to express open end which can be specified as "12:00+" for example.': {
				from: '',
			}, 'You can use notation "<ok>" for "<ko>". You might want to express open end which can be specified as "12:00+" for example.': {
				'-late': '+',
			}, 'Please use notation "<ok>" for "<ko>". If the times are unsure or vary consider a comment e.g. 12:00-14:00 "only on sunshine".': {
				'~':  '-',
				'～': '-',
			}, 'Please use notation "<ok>" for "<ko>". Fallback rule: 12:00-14:00 || "call us"': {
				'otherwise':  '||',
			}, 'You can use notation "<ok>" for "<ko>" temporally if the syntax will still be valid.': {
				'?':  'unknown "please add this if known"',
			}, 'Please use notation "<ok>" for "<ko>".': {
				'→':  '-',
				'–':  '-',
				'−':  '-',
				'=':  '-',
				'ー': '-',
				to:   '-',
				'до': '-',
				a:    '-', // language unknown
				as:   '-', // language unknown
				'á':  '-', // language unknown
				'ás': '-', // language unknown
				'à':  '-', // language unknown
				'às': '-', // language unknown
				'ate':  '-', // language unknown
				'till': '-',
				'til':  '-',
				'until': '-',
				'through': '-',
				and:  ',',
				'&':  ',',
				'：':  ':',
				'°°':  ':00',
				'daily':     'Mo-Su',
				'everyday':  'Mo-Su',
				'every day': 'Mo-Su',
				always:    '24/7',
				nonstop:   '24/7',
				'24x7':    '24/7',
				'anytime': '24/7',
				'all day': '24/7',
				'all days': 'Mo-Su',
				'every day': 'Mo-Su',
				'7days':   'Mo-Su',
				'7j/7':    'Mo-Su', // I guess that it means that
				'7/7':     'Mo-Su', // I guess that it means that
				'7 days':  'Mo-Su',
				'7 days a week': 'Mo-Su',
				'midnight': '00:00',
				holiday:  'PH',
				holidays: 'PH',
				'public holidays': 'PH',
				'public holiday': 'PH',
				// summerholiday:  'SH',
				// summerholidays: 'SH',
				weekend:  'Sa,Su',
				weekends: 'Sa,Su',
				'daylight': 'sunrise-sunset',
				'оff': 'off', // Russian o
			}, 'Please use time format in 24 hours notation ("<ko>"). If PM is used you might have to convert the hours to the 24 hours notation.': {
				'pm': '',
				'рм': '',
				'am': '',
				'ам': '',
			}, 'Bitte verzichte auf "<ko>".': {
				'uhr': '',
				'geöffnet': '',
			}, 'Bitte verzichte auf "<ko>". Sie möchten eventuell eine Öffnungszeit ohne vorgegebenes Ende angeben. Beispiel: "12:00+"': {
				ab:  '',
				von: '',
			}, 'Bitte benutze die Schreibweise "<ok>" für "<ko>".': {
				bis: '-',
				'täglich': 'Mo-Su',
			}, 'Bitte benutze die Schreibweise "<ok>" als Ersatz für "und" bzw. "u.".': {
				und: ',',
				u:   ',',
			}, 'Bitte benutze die englische Abkürzung "<ok>" für "<ko>".': {
				feiertag:   'PH',
				feiertags:  'PH',
				feiertage:  'PH',
				feiertagen: 'PH'
			}, 'S\'il vous plaît utiliser "<ok>" pour "<ko>".': {
				'fermé': 'off',
				'et':    ',',
				'à':     '-',
				'jours fériés': 'PH',
			}, 'Neem de engelse afkorting "<ok>" voor "<ko>" alstublieft.': {
				feestdag:   'PH',
				feestdagen: 'PH',
			}
		},

		month: {
			'default': {
				jan:  0,
				feb:  1,
				mar:  2,
				apr:  3,
				may:  4,
				jun:  5,
				jul:  6,
				aug:  7,
				sep:  8,
				oct:  9,
				nov: 10,
				dec: 11,
			}, 'Please use the English abbreviation "<ok>" for "<ko>".': {
				'jänner':   0, // Austria
				january:    0,
				february:   1,
				march:      2,
				april:      3,
				// may:     4,
				june:       5,
				july:       6,
				august:     7,
				september:  8,
				sept:       8,
				october:    9,
				november:  10,
				december:  11,
			}, 'Bitte benutze die englische Abkürzung "<ok>" für "<ko>".': {
				januar:    0,
				februar:   1,
				'märz':    2,
				maerz:     2,
				mai:       4,
				juni:      5,
				juli:      6,
				okt:       9,
				oktober:   9,
				dez:      11,
				dezember: 11,
			}, 'S\'il vous plaît utiliser l\'abréviation "<ok>" pour "<ko>".': {
				janvier:    0,
				février:    1,
				fév:        1,
				mars:       2,
				avril:      3,
				avr:        3,
				mai:        4,
				juin:       5,
				juillet:    6,
				août:       7,
				aoû:        7,
				septembre:  8,
				octobre:    9,
				novembre:  10,
				décembre:  11,
			}, 'Neem de engelse afkorting "<ok>" voor "<ko>" alstublieft.': {
				januari:  0,
				februari: 1,
				maart:    2,
				mei:      4,
				augustus: 7,
			}
		},

		weekday: { // good source: http://www.omniglot.com/language/time/days.htm
			'default': {
				su: 0,
				mo: 1,
				tu: 2,
				we: 3,
				th: 4,
				fr: 5,
				sa: 6,
			}, 'Assuming "<ok>" for "<ko>"': {
				m:          1,
				w:          3,
				f:          5,
			}, 'Please use the abbreviation "<ok>" for "<ko>".': {
				sun:        0,
				sunday:     0,
				sundays:    0,
				mon:        1,
				monday:     1,
				mondays:    1,
				tue:        2,
				tuesday:    2,
				tuesdays:   2,
				wed:        3,
				wednesday:  3,
				wednesdays: 3,
				thu:        4,
				thur:       4,
				thursday:   4,
				thursdays:  4,
				fri:        5,
				friday:     5,
				fridays:    5,
				sat:        6,
				saturday:   6,
				saturdays:  6,
			}, 'Bitte benutze die englische Abkürzung "<ok>" für "<ko>". Could also mean Saturday in Polish …': {
				so:         0,
			}, 'Bitte benutze die englische Abkürzung "<ok>" für "<ko>".': {
				son:         0,
				sonntag:     0,
				'sonn-':     0,
				sonntags:    0,
				montag:      1,
				montags:     1,
				di:          2,
				die:         2,
				dienstag:    2,
				dienstags:   2,
				mi:          3,
				mit:         3,
				mittwoch:    3,
				mittwochs:   3,
				'do':        4,
				don:         4,
				donnerstag:  4,
				donnerstags: 4,
				fre:         5,
				freitag:     5,
				freitags:    5,
				sam:         6,
				samstag:     6,
				samstags:    6,
			}, 'S\'il vous plaît utiliser l\'abréviation "<ok>" pour "<ko>".': {
				dim:      0,
				dimanche: 0,
				lu:       1,
				lun:      1,
				lundi:    1,
				mardi:    2,
				mer:      3,
				mercredi: 3,
				je:       4,
				jeu:      4,
				jeudi:    4,
				ve:       5,
				ven:      5,
				vendredi: 5,
				samedi:   6,
			}, 'Neem de engelse afkorting "<ok>" voor "<ko>" alstublieft.': {
				zo:        0,
				zon:       0,
				zontag:    0, // correct?
				zondag:    0,
				maandag:   1,
				din:       2,
				dinsdag:   2,
				wo:        3,
				woe:       3,
				woensdag:  3,
				donderdag: 4,
				vr:        5,
				vri:       5,
				vrijdag:   5,
				za:        6,
				zat:       6,
				zaterdag:  6,
			}, 'Please use the English abbreviation "<ok>" for "<ko>".': { // FIXME: Translate to Czech.
				'neděle':  0,
				'ne':      0,
				'pondělí': 1,
				'po':      1,
				'úterý':   2,
				'út':      2,
				'středa':  3,
				'st':      3,
				'čtvrtek': 4,
				'čt':      4,
				'pátek':   5,
				'pá':      5,
				'sobota':  6,
			}, 'Please use the English abbreviation "<ok>" for "<ko>".': {
				// Spanish.
				'martes':    0,
				'miércoles': 1,
				'jueves':    2,
				'viernes':   3,
				'sábado':    4,
				'domingo':   5,
				'lunes':     6,
				// Indonesian.
				'selasa': 0,
				'rabu':   1,
				'kami':   2,
				'jumat':  3,
				'sabtu':  4,
				'minggu': 5,
				'senin':  6,
				// Swedish
				'söndag':   0,
				'söndagar': 0,
				'måndag':   1,
				'ma':       1,
				'tisdag':   2,
				'onsdag':   3,
				'torsdag':  4,
				'fredag':   5,
				'lördag':   6,
				'lördagar': 6,
				// Polish
				'niedziela': 0, 'niedz': 0, 'n': 0, 'ndz': 0,
				'poniedziałek': 1, 'poniedzialek': 1, 'pon': 1, 'pn': 1,
				'wtorek': 2, 'wt': 2,
				'środa': 3, 'sroda': 3, 'śr': 3, 'sr': 3,
				'czwartek': 4, 'czw': 4, 'cz': 4,
				'piątek': 5, 'piatek': 5, 'pt': 5,
				'sobota': 6, 'sob': 6, // 'so': 6 // abbreviation also used in German
				// Russian
				'воскресенье' : 0,
				'Вс'          : 0,
				"voskresen'ye": 0,
				'понедельник' : 1,
				'Пн'          : 1,
				"ponedel'nik" : 1,
				'вторник'     : 2,
				'vtornik'     : 2,
				'среда'       : 3,
				'sreda'       : 3,
				'четверг'     : 4,
				'chetverk'    : 4,
				'пятница'     : 5,
				'pyatnitsa'   : 5,
				'суббота'     : 6,
				'subbota'     : 6,
				// Danish
				'søndag' : 0,
				'mandag' : 1,
				'tirsdag': 2,
				'onsdag' : 3,
				'torsdag': 4,
				'fredag' : 5,
				'lørdag' : 6,
			},
		},

		timevar: { // Special time variables which actual value depends on the date and the position of the facility.
			'default': {
				'sunrise': 'sunrise',
				'sunset':  'sunset',
				'dawn':    'dawn',
				'dusk':    'dusk',
			}, 'Please use notation "<ok>" for "<ko>".': {
				'sundown':  'sunset',
			}, 'Bitte benutze die Schreibweise "<ok>" für "<ko>".': {
				'morgendämmerung': 'dawn',
				'abenddämmerung':  'dusk',
				'sonnenaufgang':   'sunrise',
				'sonnenuntergang': 'sunset',
			},
		},

		'event': { // variable events
			'default': {
				'easter': 'easter',
			}, 'Bitte benutze die Schreibweise "<ok>" für "<ko>".': {
				'ostern': 'easter',
			},
		},
	};
	// }}}
	// }}}

	// make the library accessible for the outside world {{{
	if (typeof exports === 'object') {
		// For nodejs
		var SunCalc = require('suncalc');
		module.exports = factory(SunCalc, holidays, word_error_correction);
	} else {
		// For browsers
		root.opening_hours = factory(root.SunCalc, holidays, word_error_correction);
	}
	/// }}}
}(this, function (SunCalc, holidays, word_error_correction) {
	return function(value, nominatiomJSON, oh_mode) {
		// short constants {{{
		var word_value_replacement = { // if the correct values can not be calculated
			dawn    : 60 * 5 + 30,
			sunrise : 60 * 6,
			sunset  : 60 * 18,
			dusk    : 60 * 18 + 30,
		};
		var months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
		var weekdays = ['Su','Mo','Tu','We','Th','Fr','Sa'];
		var default_prettify_conf = {
			'leading_zero_hour': true,       // enforce leading zero
			'one_zero_if_hour_zero': false,  // only one zero "0" if hour is zero "0"
			'leave_off_closed': true,        // leave keywords of and closed as is
			'keyword_for_off_closed': 'off', // use given keyword instead of "off" or "closed"
			'block_sep_string': ' ',         // separate blocks by string
			'print_semicolon': true,         // print token which separates normal blocks
			'leave_weekday_sep_one_day_betw': true, // use the separator (either "," or "-" which is used to separate days which follow to each other like Sa,Su or Su-Mo
			'sep_one_day_between': ',' // separator which should be used
		};

		var minutes_in_day = 60 * 24;
		var msec_in_day    = 1000 * 60 * minutes_in_day;
		var msec_in_week   = msec_in_day * 7;
		// }}}

		// constructor parameters {{{
		// Evaluate additional information which can be given. They are
		// required to reasonably calculate 'sunrise' and to use the correct
		// holidays.
		var location_cc, location_state, lat, lon;
		if (typeof nominatiomJSON != 'undefined') {
			if (typeof nominatiomJSON.address != 'undefined' &&
					typeof nominatiomJSON.address.state != 'undefined') { // country_code will be tested later …
						location_cc    = nominatiomJSON.address.country_code;
						location_state = nominatiomJSON.address.state;
			}

			if (typeof nominatiomJSON.lon != 'undefined') { // lat will be tested later …
				lat = nominatiomJSON.lat;
				lon = nominatiomJSON.lon;
			}
		}

		// 0: time ranges (default), tags: opening_hours, lit, …
		// 1: points in time
		// 2: both (time ranges and points in time), tags: collection_times, service_times
		if (typeof oh_mode == 'undefined') {
			oh_mode = 0;
		} else if (!(typeof oh_mode == 'number' && (oh_mode == 0 || oh_mode == 1 || oh_mode == 2))) {
			throw 'The third constructor parameter is oh_mode and must be a number (0, 1 or 2)'
		}
		// }}}

		// put tokenized blocks into list {{{
		if (value.match(/^(\s*;?\s*)+$/))
			throw 'Value contains nothing meaningful which can be parsed';

		var parsing_warnings = [];
		var done_with_warnings = false; // The functions which throw warnings can be called multiple times.
		var has_token = {};
		var tokens = tokenize(value);
		// console.log(JSON.stringify(tokens, null, '\t'));
		var prettified_value = '';
		var used_subparsers = {}; // Used sub parsers for one block, will be reset for each block. Declared in global namespace, because it is manipulation inside various sub parsers.
		var week_stable = true;

		var blocks = [];

		for (var nblock = 0; nblock < tokens.length; nblock++) {
			if (tokens[nblock][0].length == 0) continue;
			// Block does contain nothing useful e.g. second block of '10:00-12:00;' (empty) which needs to be handled.

			var continue_at = 0;
			do {
				if (continue_at == tokens[nblock][0].length) break;
				// Additional block does contain nothing useful e.g. second block of '10:00-12:00,' (empty) which needs to be handled.

				var selectors = {
					// Time selectors
					time: [],

					// Temporary array of selectors from time wrapped to the next day
					wraptime: [],

					// Date selectors
					weekday: [],
					holiday: [],
					week: [],
					month: [],
					monthday: [],
					year: [],

					// Array with non-empty date selector types, with most optimal ordering
					date: [],

					fallback: tokens[nblock][1],
					additional: continue_at ? true : false,
					meaning: true,
					unknown: false,
					comment: undefined,
					build_from_token_block: undefined,
				};

				selectors.build_from_token_block = [ nblock, continue_at ];
				continue_at = parseGroup(tokens[nblock][0], continue_at, selectors, nblock);
				if (typeof continue_at == 'object')
					continue_at = continue_at[0];
				else
					continue_at = 0;

				if (selectors.year.length > 0)
					selectors.date.push(selectors.year);
				if (selectors.holiday.length > 0)
					selectors.date.push(selectors.holiday);
				if (selectors.month.length > 0)
					selectors.date.push(selectors.month);
				if (selectors.monthday.length > 0)
					selectors.date.push(selectors.monthday);
				if (selectors.week.length > 0)
					selectors.date.push(selectors.week);
				if (selectors.weekday.length > 0)
					selectors.date.push(selectors.weekday);

				// console.log('weekday: ' + JSON.stringify(selectors.weekday, null, '\t'));
				blocks.push(selectors);

				// This handles selectors with time ranges wrapping over midnight (e.g. 10:00-02:00)
				// it generates wrappers for all selectors and creates a new block.
				if (selectors.wraptime.length > 0) {
					var wrapselectors = {
						time: selectors.wraptime,
						date: [],

						meaning: selectors.meaning,
						unknown: selectors.unknown,
						comment: selectors.comment,

						wrapped: true,
					};

					for (var dselg = 0; dselg < selectors.date.length; dselg++) {
						wrapselectors.date.push([]);
						for (var dsel = 0; dsel < selectors.date[dselg].length; dsel++) {
							wrapselectors.date[wrapselectors.date.length-1].push(
									generateDateShifter(selectors.date[dselg][dsel], -msec_in_day)
								);
						}
					}

					blocks.push(wrapselectors);
				}
			} while (continue_at)
		}
		// }}}

		/* Tokenization function: Splits string into parts. {{{
		 *
		 * :param value: Raw opening_hours value.
		 * :returns: Tokenized list object. Complex structure. You can print the
		 *		thing as JSON if you would like to know in details.
		 *		The most inner list has the following items: [ internal_value, token_name, value_length ].
		 */
		function tokenize(value) {
			var all_tokens        = new Array();
			var curr_block_tokens = new Array();

			var last_block_fallback_terminated = false;

			while (value != '') {
				var tmp;
				if (tmp = value.match(/^(?:week\b|open\b|unknown\b)/i)) {
					// Reserved keywords.
					curr_block_tokens.push([tmp[0].toLowerCase(), tmp[0].toLowerCase(), value.length ]);
					value = value.substr(tmp[0].length);
				} else if (tmp = value.match(/^24\/7/i)) {
					// Reserved keyword.
					has_token[tmp[0]] = true;
					curr_block_tokens.push([tmp[0], tmp[0], value.length ]);
					value = value.substr(tmp[0].length);
				} else if (tmp = value.match(/^(?:off|closed)/i)) {
					// Reserved keywords.
					curr_block_tokens.push([tmp[0].toLowerCase(), 'closed', value.length ]);
					value = value.substr(tmp[0].length);
				} else if (tmp = value.match(/^(?:PH|SH)/i)) {
					// special day name (holidays)
					curr_block_tokens.push([tmp[0].toUpperCase(), 'holiday', value.length ]);
					value = value.substr(2);
				} else if (tmp = value.match(/^days?/i)) {
					curr_block_tokens.push([tmp[0].toLowerCase(), 'calcday', value.length ]);
					value = value.substr(tmp[0].length);
				} else if (tmp = value.match(/^(&|_|→|–|−|=|opening_hours=|ー|\?|~|～|：|°°|25x7|7[ ]?days( a week|)|all days?|every day|-late|public holidays?|7j?\/7|every day|до|рм|ам|jours fériés|sonn-|[a-zäößàáéøčěíúýřПнВсо]+\b)\.?/i)) {
					// Handle all remaining words with error tolerance.
					var correct_val = returnCorrectWordOrToken(tmp[1].toLowerCase(), value.length);
					if (typeof correct_val == 'object') {
						curr_block_tokens.push([ correct_val[0], correct_val[1], value.length ]);
						value = value.substr(tmp[0].length);
					} else if (typeof correct_val == 'string') {
						if (tmp[1].toLowerCase() == 'pm') {
							var hours_token_at = curr_block_tokens.length - 3;
							if (hours_token_at > 0) {
								if (matchTokens(curr_block_tokens, hours_token_at,
											'number', 'timesep', 'number')
										) {
									var hours_token = curr_block_tokens[hours_token_at];
								} else if (matchTokens(curr_block_tokens, hours_token_at + 2,
											'number')
										) {
									hours_token_at += 2;
									var hours_token = curr_block_tokens[hours_token_at];
								}
								if (hours_token[0] <= 12) {
									hours_token[0] += 12;
									curr_block_tokens[hours_token_at] = hours_token;
								}
							}
						}
						value = correct_val + value.substr(tmp[0].length);
					} else {
						// other single-character tokens
						curr_block_tokens.push([value[0].toLowerCase(), value[0].toLowerCase(), value.length - 1 ]);
						value = value.substr(1);
					}
				} else if (tmp = value.match(/^\d+/)) {
					// number
					if (tmp[0] > 1900) // Assumed to be a year number.
						curr_block_tokens.push([tmp[0], 'year', value.length ]);
					else
						curr_block_tokens.push([+tmp[0], 'number', value.length ]);
					value = value.substr(tmp[0].length);
				} else if (tmp = value.match(/^"([^"]*)"/)) {
					// comment
					curr_block_tokens.push([tmp[1], 'comment', value.length ]);
					value = value.substr(tmp[0].length);
				} else if (value.match(/^;/)) {
					// semicolon terminates block
					// next tokens belong to a new block
					all_tokens.push([ curr_block_tokens, last_block_fallback_terminated, value.length ]);
					value = value.substr(1);

					curr_block_tokens = [];
					last_block_fallback_terminated = false;
				} else if (value.match(/^\|\|/)) {
					// || terminates block
					// next tokens belong to a fallback block
					if (curr_block_tokens.length == 0)
						throw formatWarnErrorMessage(-1, value.length - 2, 'Rule before fallback rule does not contain anything useful');

					all_tokens.push([ curr_block_tokens, last_block_fallback_terminated, value.length ]);
					value = value.substr(2);

					curr_block_tokens = [];
					last_block_fallback_terminated = true;
				} else if (value.match(/^(?:␣|\s)/)) {
					// Using "␣" as space is not expected to be a normal mistake. Just ignore it to make using taginfo easier.
					value = value.substr(1);
				} else if (tmp = value.match(/^\s+/)) {
					// whitespace is ignored
					value = value.substr(tmp[0].length);
				} else if (value.match(/^[:.]/)) {
					// time separator
					if (value[0] == '.' && !done_with_warnings)
						parsing_warnings.push([ -1, value.length - 1, 'Please use ":" as hour/minute-separator' ]);
					curr_block_tokens.push([ ':', 'timesep', value.length ]);
					value = value.substr(1);
				} else {
					// other single-character tokens
					curr_block_tokens.push([value[0].toLowerCase(), value[0].toLowerCase(), value.length ]);
					value = value.substr(1);
				}
			}

			all_tokens.push([ curr_block_tokens, last_block_fallback_terminated ]);

			return all_tokens;
		}
		// }}}

		/* error correction/tolerance function {{{
		 * Go through word_error_correction hash and get correct value back.
		 *
		 * :param word: Wrong Word or character.
		 * :param value_length: Current value_length (used for warnings).
		 * :returns:
		 *		* (valid) opening_hours sub string.
		 *		* object with [ internal_value, token_name ] if value is correct.
		 *		* undefined if word could not be found (and thus not be corrected).
		 */
		function returnCorrectWordOrToken(word, value_length) {
			for (var token_name in word_error_correction) {
				for (var comment in word_error_correction[token_name]) {
					for (var old_val in word_error_correction[token_name][comment]) {
						if (old_val == word) {
							var val = word_error_correction[token_name][comment][old_val];
							if (comment == 'default') {
								// Return internal representation of word.
								return [ val, token_name ];
							} else if (token_name == 'wrong_words' && !done_with_warnings) {
								// Replace wrong words or characters with correct ones.
								// This will return a string which is then being tokenized.
								parsing_warnings.push([ -1, value_length - old_val.length,
									comment.replace(/<ko>/, old_val).replace(/<ok>/, val) ]);
								return val;
							} else {
								// Get correct string value from the 'default' hash and generate warning.
								var correct_abbr;
								for (correct_abbr in word_error_correction[token_name]['default']) {
									if (word_error_correction[token_name]['default'][correct_abbr] == val)
										break;
								}
								if (typeof correct_abbr == 'undefined') {
									throw 'Please file a bug for opening_hours.js.'
										+ ' Including the stacktrace.'
								}
								if (token_name != 'timevar') {
									// Everything else than timevar:
									// E.g. 'Mo' are start with a upper case letter.
									// It just looks better.
									correct_abbr = correct_abbr.charAt(0).toUpperCase()
										+ correct_abbr.slice(1);
								}
								if (!done_with_warnings)
									parsing_warnings.push([ -1, value_length - old_val.length,
										comment.replace(/<ko>/, old_val).replace(/<ok>/, correct_abbr) ]);
								return [ val, token_name ];
							}
						}
					}
				}
			}
			return undefined;
		}
		// }}}

		/* return warnings as list {{{
		 *
		 * :param it: Iterator object if available (optional).
		 * :returns: Warnings as list with one warning per element.
		 */
		function getWarnings(it) {
			if (typeof it == 'object') { // getWarnings was called in a state without critical errors. We can do extended tests.

				// Check if 24/7 is used and it does not mean 24/7 because there are other blocks.
				var has_advanced = it.advance();

				if (has_advanced === true && has_token['24/7'] && !done_with_warnings) {
					parsing_warnings.push([ -1, 0, 'You used 24/7 in a way that is probably not interpreted as "24 hours 7 days a week".'
							// Probably because of: "24/7; 12:00-14:00 open", ". Needs extra testing.
							+ ' For correctness you might want to use "open" or "closed"'
							+ ' for this rule and then write your exceptions which should achieve the same goal and is more clear'
							+ ' e.g. "open; Mo 12:00-14:00 off".']);
				}
			}

			var warnings = [];
			for (var i = 0; i < parsing_warnings.length; i++) {
				warnings.push( formatWarnErrorMessage(parsing_warnings[i][0], parsing_warnings[i][1], parsing_warnings[i][2]) );
			}
			return warnings;
		}
		// }}}

		/* Function to check token array for specific pattern {{{
		 *
		 * :param tokens: List of token objects.
		 * :param at: Position at which the matching should begin.
		 * :param token_name(s): One or many token_name strings which have to match in that order.
		 * :returns: true if token_name(s) match in order false otherwise.
		 */
		function matchTokens(tokens, at /*, matches... */) {
			if (at + arguments.length - 2 > tokens.length)
				return false;
			for (var i = 0; i < arguments.length - 2; i++) {
				if (tokens[at + i][1] !== arguments[i + 2])
					return false;
			}

			return true;
		}
		// }}}

		/* Generate selector wrapper with time offset {{{
		 *
		 * :param func: Generated selector code function.
		 * :param shirt: Time to shift in milliseconds.
		 * :param token_name(s): One or many token_name strings which have to match in that order.
		 * :returns: See selector code.
		 */
		function generateDateShifter(func, shift) {
			return function(date) {
				var res = func(new Date(date.getTime() + shift));

				if (typeof res[1] === 'undefined')
					return res;
				return [ res[0], new Date(res[1].getTime() - shift) ];
			}
		}
		// }}}

		/* Top-level parser {{{
		 *
		 * :param tokens: List of token objects.
		 * :param at: Position where to start.
		 * :param selectors: Reference to selector object.
		 * :param nblock: Block number starting with 0.
		 * :param conf: Configuration for prettifyValue.
		 * :returns: See selector code.
		 */
		function parseGroup(tokens, at, selectors, nblock, conf) {
			var prettified_group_value = '';
			used_subparsers = { 'time ranges': [ ] };

			// console.log(tokens); // useful for debugging of tokenize
			while (at < tokens.length) {
				var old_at = at;
				// console.log('Parsing at position', at +':', tokens[at]);
				if (matchTokens(tokens, at, 'weekday')) {
					at = parseWeekdayRange(tokens, at, selectors);
				} else if (matchTokens(tokens, at, '24/7')) {
					selectors.time.push(function(date) { return [true]; });
					// Not needed. If there is no selector it automatically matches everything.
					// WRONG: This only works if there is no other selector in this selector group ...
					at++;
				} else if (matchTokens(tokens, at, 'holiday')) {
					if (matchTokens(tokens, at+1, ','))
						at = parseHoliday(tokens, at, selectors, true);
					else
						at = parseHoliday(tokens, at, selectors, false);
					week_stable = false;
				} else if (matchTokens(tokens, at, 'month', 'number')
						|| matchTokens(tokens, at, 'month', 'weekday')
						|| matchTokens(tokens, at, 'year', 'month', 'number')
						|| matchTokens(tokens, at, 'year', 'event')
						|| matchTokens(tokens, at, 'event')) {
					at = parseMonthdayRange(tokens, at, nblock);
					week_stable = false;
				} else if (matchTokens(tokens, at, 'year')) {
					at = parseYearRange(tokens, at);
					week_stable = false;
				} else if (matchTokens(tokens, at, 'month')) {
					at = parseMonthRange(tokens, at);
					// week_stable = false; // decided based on actual values
				} else if (matchTokens(tokens, at, 'week')) {
					at = parseWeekRange(tokens, at + 1);
					week_stable = false;

					// if (prettified_group_value[-1] != ' ')
					// 	prettified_group_value = prettified_group_value.substring(0, prettified_group_value.length - 1);
				} else if (at != 0 && at != tokens.length - 1 && tokens[at][0] == ':') {
					// Ignore colon if they appear somewhere else than as time separator.
					// Except the start or end of the value.
					// This provides compatibility with the syntax proposed by Netzwolf:
					// http://wiki.openstreetmap.org/wiki/Key:opening_hours:specification
					if (!done_with_warnings && (matchTokens(tokens, at-1, 'weekday') || matchTokens(tokens, at-1, 'holiday')))
						parsing_warnings.push([nblock, at, 'Please don’t use ":" after ' + tokens[at-1][1] + '.']);

					if (prettified_group_value[-1] != ' ')
						prettified_group_value = prettified_group_value.substring(0, prettified_group_value.length - 1);
					at++;
				} else if (matchTokens(tokens, at, 'number', 'timesep')
						|| matchTokens(tokens, at, 'timevar')
						|| matchTokens(tokens, at, '(', 'timevar')
						|| matchTokens(tokens, at, 'number', '-')) {
					at = parseTimeRange(tokens, at, selectors, false);

					used_subparsers['time ranges'].push(at);
				} else if (matchTokens(tokens, at, 'closed')) {
					selectors.meaning = false;
					at++;
					if (matchTokens(tokens, at, ',')) // additional block
						at = [ at + 1 ];

					if (typeof used_subparsers['state keywords'] != 'object')
						used_subparsers['state keywords'] = [ at ];
					else
						used_subparsers['state keywords'].push(at);
				} else if (matchTokens(tokens, at, 'open')) {
					selectors.meaning = true;
					at++;
					if (matchTokens(tokens, at, ',')) // additional block
						at = [ at + 1 ];

					if (typeof used_subparsers['state keywords'] != 'object')
						used_subparsers['state keywords'] = [ at ];
					else
						used_subparsers['state keywords'].push(at);
				} else if (matchTokens(tokens, at, 'unknown')) {
					selectors.meaning = false;
					selectors.unknown = true;
					at++;
					if (matchTokens(tokens, at, ',')) // additional block
						at = [ at + 1 ];

					if (typeof used_subparsers['state keywords'] != 'object')
						used_subparsers['state keywords'] = [ at ];
					else
						used_subparsers['state keywords'].push(at);
				} else if (matchTokens(tokens, at, 'comment')) {
					selectors.comment = tokens[at][0];
					if (at > 0) {
						if (!matchTokens(tokens, at - 1, 'open')
							&& !matchTokens(tokens, at - 1, 'closed')) {
							// Then it is unknown. Either with unknown explicitly
							// specified or just a comment behind.
							selectors.meaning = false;
							selectors.unknown = true;
						}
					} else { // block starts with comment
						selectors.time.push(function(date) { return [true]; });
						// Not needed. If there is no selector it automatically matches everything.
						// WRONG: This only works if there is no other selector in this selector group ...
						selectors.meaning = false;
						selectors.unknown = true;
					}
					at++;
					if (matchTokens(tokens, at, ',')) // additional block
						at = [ at + 1 ];

					if (typeof used_subparsers['comments'] != 'object')
						used_subparsers['comments'] = [ at ];
					else
						used_subparsers['comments'].push(at);
				} else {
					var warnings = getWarnings();
					throw formatWarnErrorMessage(nblock, at, 'Unexpected token: "' + tokens[at][1]
						+ '" This means that the syntax is not valid at that point or it is currently not supported.')
						+ (warnings ? ' ' + warnings.join('; ') : '');
				}

				if (typeof conf != 'undefined') {
					// 'Mo: 12:00-13:00' -> 'Mo 12:00-13:00'
					if (used_subparsers['time ranges'] && old_at > 1 && tokens[old_at-1][0] == ':'
							&& matchTokens(tokens, old_at - 2, 'weekday'))
						prettified_group_value = prettified_group_value.substring(0, prettified_group_value.length - 2) + ' ';

					// 'week 1, week 3' -> 'week 1,week 3'
					if (prettified_group_value.substr(prettified_group_value.length -2, 2) == ', '
							&& matchTokens(tokens, old_at, 'week'))
						prettified_group_value = prettified_group_value.substring(0, prettified_group_value.length - 1);

					prettified_group_value += prettifySelector(tokens, old_at, at, conf, used_subparsers['time ranges'].length);
				}

				if (typeof at == 'object') // additional block
					break;
			}

			prettified_value += prettified_group_value.replace(/\s+$/, '');

			if (!done_with_warnings) {
				for (var subparser_name in used_subparsers) {
					if (used_subparsers[subparser_name].length > 1) {
						parsing_warnings.push([nblock, used_subparsers[subparser_name][used_subparsers[subparser_name].length - 1] - 1,
							'You have used ' + used_subparsers[subparser_name].length
							+ (subparser_name.match(/^(?:comments|state keywords)/) ?
									' ' + subparser_name + ' in one rule.'
									+ ' You may only use one in one rule.'
								:
									' not connected ' + subparser_name + ' in one rule.'
									+ ' This is probably an error.'
									+ ' Equal selector types can (and should) always be written in conjunction separated by comma or something.'
									+ ' Example for time ranges "12:00-13:00,15:00-18:00".'
									+ ' Example for weekdays "Mo-We,Fr".'
							 )
							+ ' Rules can be separated by ";".' ]
						);
					}
				}
			}

			return at;
		}
		// }}}

		// helper functions for sub parser {{{

		/* For given date, returns date moved to the start of the day with an offset specified in minutes. {{{
		 * For example, if date is 2014-05-19_18:17:12, dateAtDayMinutes would
		 * return 2014-05-19_02:00:00 for minutes=120.
		 *
		 * :param date: Date object.
		 * :param minutes: Minutes used as offset starting from midnight of current day.
		 * :returns: Moved date object.
		 */
		function dateAtDayMinutes(date, minutes) {
			return new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, minutes);
		}
		// }}}

		/* For given date, returns date moved to the specific day of week {{{
		 *
		 * :param date: Date object.
		 * :param weekday: Integer number for day of week. Starting with zero (Sunday).
		 * :returns: Moved date object.
		 */
		function dateAtNextWeekday(date, weekday) {
			var delta = weekday - date.getDay();
			return new Date(date.getFullYear(), date.getMonth(), date.getDate() + delta + (delta < 0 ? 7 : 0));
		}
		// }}}

		/* Function to determine whether an array contains a value {{{
		 * Source: http://stackoverflow.com/a/1181586
		 *
		 * :param needle: Element to find.
		 * :returns: Index of element if present, if not present returns -1.
		 */
		function indexOf(needle) {
			if(typeof Array.prototype.indexOf === 'function') {
				indexOf = Array.prototype.indexOf;
			} else {
				indexOf = function(needle) {
					var i = -1, index = -1;
					for(i = 0; i < this.length; i++) {
						if(this[i] === needle) {
							index = i;
							break;
						}
					}
					return index;
				};
			}
			return indexOf.call(this, needle);
		}
		// }}}

		/* Numeric list parser (1,2,3-4,-1) {{{
		 * Used in weekday parser above.
		 *
		 * :param tokens: List of token objects.
		 * :param at: Position where to start.
		 * :param func: Function func(from, to, at).
		 * :returns: Position at which the token does not belong to the list any more.
		 */
		function parseNumRange(tokens, at, func) {
			for (; at < tokens.length; at++) {
				if (matchTokens(tokens, at, 'number', '-', 'number')) {
					// Number range
					func(tokens[at][0], tokens[at+2][0], at);
					at += 3;
				} else if (matchTokens(tokens, at, '-', 'number')) {
					// Negative number
					func(-tokens[at+1][0], -tokens[at+1][0], at);
					at += 2
				} else if (matchTokens(tokens, at, 'number')) {
					// Single number
					func(tokens[at][0], tokens[at][0], at);
					at++;
				} else {
					throw formatWarnErrorMessage(nblock, at + matchTokens(tokens, at, '-'),
						'Unexpected token in number range: ' + tokens[at][1]);
				}

				if (!matchTokens(tokens, at, ','))
					break;
			}

			return at;
		}
		// }}}

		/* List parser for constrained weekdays in month range {{{
		 * e.g. Su[-1] which selects the last Sunday of the month.
		 *
		 * :param tokens: List of token objects.
		 * :param at: Position where to start.
		 * :returns: Array:
		 *			0. Constrained weekday number.
		 *			1. Position at which the token does not belong to the list any more (after ']' token).
		 */
		function getConstrainedWeekday(tokens, at) {
			var number = 0;
			var endat = parseNumRange(tokens, at, function(from, to, at) {

				// bad number
				if (from == 0 || from < -5 || from > 5)
					throw formatWarnErrorMessage(nblock, at,
						'Number between -5 and 5 (except 0) expected');

				if (from == to) {
					if (number != 0)
						throw formatWarnErrorMessage(nblock, at,
							'You can not use more than one constrained weekday in a month range');
					number = from;
				} else {
					throw formatWarnErrorMessage(nblock, at+2,
						'You can not use a range of constrained weekdays in a month range');
				}
			});

			if (!matchTokens(tokens, endat, ']'))
				throw formatWarnErrorMessage(nblock, endat, '"]" expected.');

			return [ number, endat + 1 ];
		}
		// }}}

		// Check if period is ok. Period 0 or 1 don’t make much sense.
		function checkPeriod(at, period, period_type, parm_string) {
			if (done_with_warnings)
				return;

			if (period === 0) {
				throw formatWarnErrorMessage(nblock, at,
					'You can not use '+ period_type +' ranges with period equals zero.');
			} else if (period === 1) {
				if (typeof parm_string == 'string' && parm_string == 'no_end_year')
					parsing_warnings.push([nblock, at,
						'Please don’t use '+ period_type +' ranges with period equals one.'
						+ ' If you want to express that a facility is open starting from a year without limit use "<year>+".']);
				else
					parsing_warnings.push([nblock, at,
						'Please don’t use '+ period_type +' ranges with period equals one.']);
			}
		}

		/* Get date moved to constrained weekday (and moved for add_days. {{{
		 * E.g. used for 'Aug Su[-1] -1 day'.
		 *
		 * :param year: Year as integer.
		 * :param month: Month as integer starting with zero.
		 * :param weekday: Integer number for day of week. Starting with zero (Sunday).
		 * :param constrained_weekday: Position where to start.
		 * :returns: Date object.
		 */
		function getDateForConstrainedWeekday(year, month, weekday, constrained_weekday, add_days) {
			var tmp_date = dateAtNextWeekday(
				new Date(year, month + (constrained_weekday[0] > 0 ? 0 : 1), 1), weekday);

			tmp_date.setDate(tmp_date.getDate() + (constrained_weekday[0] + (constrained_weekday[0] > 0 ? -1 : 0)) * 7);

			if (typeof add_days != 'undefined' && add_days[1])
				tmp_date.setDate(tmp_date.getDate() + add_days[0]);

			return tmp_date;
		}
		// }}}

		/* Format warning or error message for the user. {{{
		 *
		 * :param nblock: Block number starting with 0.
		 * :param at: Position at which the matching should begin.
		 * :param message: Human readable string with the message.
		 * :returns: String with position of the warning or error marked for the user.
		 */
		function formatWarnErrorMessage(nblock, at, message) {
			var pos = 0;
			if (nblock == -1) { // Usage of block index not required because we do have access to value.length.
				pos = value.length - at;
			} else { // Issue accrued at a later time, position in string needs to be reconstructed.
				if (typeof tokens[nblock][0][at] == 'undefined') {
					pos = value.length;
					if (typeof tokens[nblock][0][tokens[nblock][0].length-1] != 'undefined') {
						// pos -= tokens[nblock][0][tokens[nblock][0].length-1][2];
						console.warn("FIXME");
					}
				} else {
					pos = value.length;
					if (typeof tokens[nblock][0][at+1] != 'undefined') {
						pos -= tokens[nblock][0][at+1][2];
					} else if (typeof tokens[nblock][2] != 'undefined') {
						pos -= tokens[nblock][2];
					} else {
					}
				}
			}
			return value.substring(0, pos) + ' <--- (' + message + ')';
		}
		// }}}

		/* Check if date is valid. {{{
		 *
		 * :param month: Month as integer starting with zero.
		 * :param date: Day of month as integer.
		 * :returns: undefined. There is no real return value. This function just throws an exception if something is wrong.
		 */
		function isValidDate(month, day, nblock, at) {
			// May use this instead. The problem is that this does not give feedback as precise as the code which is used in this function.
			// var testDate = new Date(year, month, day);
			// if (testDate.getDate() != day || testDate.getMonth() != month || testDate.getFullYear() != year) {
			// 	console.error('date not valid');
			// }

			// https://en.wikipedia.org/wiki/Month#Julian_and_Gregorian_calendars
			if (day < 1 || day > 31)
				throw formatWarnErrorMessage(nblock, at, 'Day must be between 1 and 31.');
			if ((month==3 || month==5 || month==8 || month==10) && day==31)
				throw formatWarnErrorMessage(nblock, at, 'Month ' + months[month] + " doesn't have 31 days.!");
			if (month == 1 && day == 30)
				throw formatWarnErrorMessage(nblock, at, 'Month ' + months[1]+ " either has 28 or 29 days (leap years).");
		}
		// }}}
		// }}}

		/* Time range parser (10:00-12:00,14:00-16:00) {{{
		 *
		 * :param tokens: List of token objects.
		 * :param at: Position where to start.
		 * :param selectors: Reference to selector object.
		 * :param extended_open_end: Used for combined time range with open end.
		 * extended_open_end: <time> - <time> +
		 *            param at is here A (if extended_open_end is true)
		 * :returns: Position at which the token does not belong to the selector anymore.
		 */
		function parseTimeRange(tokens, at, selectors, extended_open_end) {
			for (; at < tokens.length; at++) {
				var has_time_var_calc = [], has_normal_time = []; // element 0: start time, 1: end time
				has_normal_time[0] = matchTokens(tokens, at, 'number', 'timesep', 'number');
				has_time_var_calc[0] = matchTokens(tokens, at, '(', 'timevar');
				if (has_normal_time[0] || matchTokens(tokens, at, 'timevar') || has_time_var_calc[0]) {
					// relying on the fact that always *one* of them is true

					var is_point_in_time = false; // default no time range
					var has_open_end     = false; // default no open end
					var timevar_add      = [ 0, 0 ];
					var timevar_string   = [];    // capture timevar string like 'sunrise' to calculate it for the current date.

					// minutes_from
					if (has_normal_time[0]) {
						var minutes_from = getMinutesByHoursMinutes(tokens, nblock, at+has_time_var_calc[0]);
					} else {
						timevar_string[0] = tokens[at+has_time_var_calc[0]][0];
						var minutes_from = word_value_replacement[timevar_string[0]];

						if (has_time_var_calc[0]) {
							timevar_add[0] = parseTimevarCalc(tokens, at);
							minutes_from += timevar_add[0];
						}
					}

					var at_end_time = at+(has_normal_time[0] ? 3 : (has_time_var_calc[0] ? 7 : 1))+1; // after '-'
					if (!matchTokens(tokens, at_end_time - 1, '-')) { // not time range
						if (matchTokens(tokens, at_end_time - 1, '+')) {
							has_open_end = true;
						} else {
							if (oh_mode == 0) {
								throw formatWarnErrorMessage(nblock, at+(
										has_normal_time[0] ? (
												typeof tokens[at+3] == 'object' ? 3 : 2
											) : (
												has_time_var_calc[0] ? 2 : 1
											)
										),
									'hyphen (-) or open end (+) in time range '
									+ (has_time_var_calc[0] ? 'calculation ' : '') + 'expected.'
									+ ' For working with points in time, the mode for opening_hours.js has to be altered.'
									+ ' Maybe wrong tag?');
							} else {
								var minutes_to = minutes_from + 1;
								is_point_in_time = true;
							}
						}
					}

					// minutes_to
					if (has_open_end) {
						if (minutes_from >= 22 * 60)
							var minutes_to = minutes_from +  8 * 60;
						else if (minutes_from >= 17 * 60)
							var minutes_to = minutes_from + 10 * 60;
						else
							var minutes_to = minutes_in_day;
					} else if (!is_point_in_time) {
						has_normal_time[1] = matchTokens(tokens, at_end_time, 'number', 'timesep', 'number');
						has_time_var_calc[1]      = matchTokens(tokens, at_end_time, '(', 'timevar');
						if (!has_normal_time[1] && !matchTokens(tokens, at_end_time, 'timevar') && !has_time_var_calc[1]) {
							throw formatWarnErrorMessage(nblock, at_end_time, 'time range does not continue as expected');
						} else {
							if (has_normal_time[1]) {
								var minutes_to = getMinutesByHoursMinutes(tokens, nblock, at_end_time);
							} else {
								timevar_string[1] = tokens[at_end_time+has_time_var_calc[1]][0]
								var minutes_to = word_value_replacement[timevar_string[1]];
							}

							if (has_time_var_calc[1]) {
								timevar_add[1] = parseTimevarCalc(tokens, at_end_time);
								minutes_to += timevar_add[1];
							}
						}
					}

					at = at_end_time + (is_point_in_time ? -1 :
							(has_normal_time[1] ? 3 : (has_time_var_calc[1] ? 7 : !has_open_end))
						);

					if (matchTokens(tokens, at, '/', 'number')) {
						if (matchTokens(tokens, at + 2, 'timesep', 'number')) { // /hours:minutes
							var point_in_time_period = getMinutesByHoursMinutes(tokens, nblock, at + 1);
							at += 4;
						} else { // /minutes
							var point_in_time_period = tokens[at + 1][0];
							at += 2;
							if (matchTokens(tokens, at, 'timesep'))
								throw formatWarnErrorMessage(nblock, at,
									'Time period does not continue as expected. Exampe "/01:30".');
						}

						if (oh_mode == 0)
							throw formatWarnErrorMessage(nblock, at - 1,
								'opening_hours is running in "time range mode". Found point in time.');

						is_point_in_time = true;
					} else if (matchTokens(tokens, at, '+')) {
						parseTimeRange(tokens, at_end_time, selectors, true);
						at++;
					} else if (oh_mode == 1 && !is_point_in_time) {
						throw formatWarnErrorMessage(nblock, at_end_time,
							'opening_hours is running in "points in time mode". Found time range.');
					}

					if (typeof lat != 'undefined') { // lon will also be defined (see above)
						if (!has_normal_time[0] || !(has_normal_time[1] || has_open_end || is_point_in_time) )
							week_stable = false;
					} else { // we can not calculate exact times so we use the already applied constants (word_value_replacement).
						timevar_string = [];
					}

					// normalize minutes into range
					if (!extended_open_end && minutes_from >= minutes_in_day)
						throw formatWarnErrorMessage(nblock, at_end_time - 1,
							'Time range starts outside of the current day');
					if (minutes_to < minutes_from || ((has_normal_time[0] && has_normal_time[1]) && minutes_from == minutes_to))
						minutes_to += minutes_in_day;
					if (minutes_to > minutes_in_day * 2)
						throw formatWarnErrorMessage(nblock, at_end_time + (has_normal_time[1] ? 4 : (has_time_var_calc[1] ? 7 : 1)) - 2,
							'Time spanning more than two midnights not supported');

					// this shortcut makes always-open range check faster
					if (!(minutes_from == 0 && minutes_to == minutes_in_day)) {
						if (minutes_to > minutes_in_day) { // has_normal_time[1] must be true
							selectors.time.push(function(minutes_from, minutes_to, timevar_string, timevar_add, has_open_end, is_point_in_time, point_in_time_period) { return function(date) {
								var ourminutes = date.getHours() * 60 + date.getMinutes();

								if (timevar_string[0]) {
									var date_from = eval('SunCalc.getTimes(date, lat, lon).' + timevar_string[0]);
									minutes_from  = date_from.getHours() * 60 + date_from.getMinutes() + timevar_add[0];
								}
								if (timevar_string[1]) {
									var date_to = eval('SunCalc.getTimes(date, lat, lon).' + timevar_string[1]);
									minutes_to  = date_to.getHours() * 60 + date_to.getMinutes() + timevar_add[1];
									minutes_to += minutes_in_day;
									// Needs to be added because it was added by
									// normal times: if (minutes_to < minutes_from)
									// above the selector construction.
								} else if (is_point_in_time && typeof point_in_time_period != 'number') {
									minutes_to = minutes_from + 1;
								}

								if (typeof point_in_time_period == 'number') {
									if (ourminutes < minutes_from) {
										return [false, dateAtDayMinutes(date, minutes_from)];
									} else if (ourminutes <= minutes_to) {
										for (var cur_min = minutes_from; ourminutes + point_in_time_period >= cur_min; cur_min += point_in_time_period) {
											if (cur_min == ourminutes) {
												return [true, dateAtDayMinutes(date, ourminutes + 1)];
											} else if (ourminutes < cur_min) {
												return [false, dateAtDayMinutes(date, cur_min)];
											}
										}
									}
									return [false, dateAtDayMinutes(date, minutes_in_day)];
								} else {
									if (ourminutes < minutes_from)
										return [false, dateAtDayMinutes(date, minutes_from)];
									else
										return [true, dateAtDayMinutes(date, minutes_to), has_open_end];
								}
							}}(minutes_from, minutes_to, timevar_string, timevar_add, has_open_end, is_point_in_time, point_in_time_period));

							selectors.wraptime.push(function(minutes_from, minutes_to, timevar_string, timevar_add, has_open_end, is_point_in_time, point_in_time_period) { return function(date) {
								var ourminutes = date.getHours() * 60 + date.getMinutes();

								if (timevar_string[0]) {
									var date_from = eval('SunCalc.getTimes(date, lat, lon).' + timevar_string[0]);
									minutes_from  = date_from.getHours() * 60 + date_from.getMinutes() + timevar_add[0];
								}
								if (timevar_string[1]) {
									var date_to = eval('SunCalc.getTimes(date, lat, lon).' + timevar_string[1]);
									minutes_to  = date_to.getHours() * 60 + date_to.getMinutes() + timevar_add[1];
									// minutes_in_day does not need to be added.
									// For normal times in it was added in: if (minutes_to < // minutes_from)
									// above the selector construction and
									// subtracted in the selector construction call
									// which returns the selector function.
								}

								if (typeof point_in_time_period == 'number') {
									if (ourminutes <= minutes_to) {
										for (var cur_min = 0; ourminutes + point_in_time_period >= cur_min; cur_min += point_in_time_period) {
											if (cur_min == ourminutes) {
												return [true, dateAtDayMinutes(date, ourminutes + 1)];
											} else if (ourminutes < cur_min) {
												return [false, dateAtDayMinutes(date, cur_min)];
											}
										}
									}
								} else {
									if (ourminutes < minutes_to)
										return [true, dateAtDayMinutes(date, minutes_to), has_open_end];
								}
								return [false, undefined];
							}}(minutes_from, minutes_to - minutes_in_day, timevar_string, timevar_add, has_open_end, is_point_in_time, point_in_time_period));
						} else {
							selectors.time.push(function(minutes_from, minutes_to, timevar_string, timevar_add, has_open_end, is_point_in_time, point_in_time_period) { return function(date) {
								var ourminutes = date.getHours() * 60 + date.getMinutes();

								if (timevar_string[0]) {
									var date_from = eval('SunCalc.getTimes(date, lat, lon).' + timevar_string[0]);
									minutes_from  = date_from.getHours() * 60 + date_from.getMinutes() + timevar_add[0];
								}
								if (timevar_string[1]) {
									var date_to = eval('SunCalc.getTimes(date, lat, lon).' + timevar_string[1]);
									minutes_to  = date_to.getHours() * 60 + date_to.getMinutes() + timevar_add[1];
								} else if (is_point_in_time && typeof point_in_time_period != 'number') {
									minutes_to = minutes_from + 1;
								}

								if (typeof point_in_time_period == 'number') {
									if (ourminutes < minutes_from) {
										return [false, dateAtDayMinutes(date, minutes_from)];
									} else if (ourminutes <= minutes_to) {
										for (var cur_min = minutes_from; ourminutes + point_in_time_period >= cur_min; cur_min += point_in_time_period) {
											if (cur_min == ourminutes) {
												return [true, dateAtDayMinutes(date, ourminutes + 1)];
											} else if (ourminutes < cur_min) {
												return [false, dateAtDayMinutes(date, cur_min)];
											}
										}
									}
									return [false, dateAtDayMinutes(date, minutes_in_day)];
								} else {
									if (ourminutes < minutes_from)
										return [false, dateAtDayMinutes(date, minutes_from)];
									else if (ourminutes < minutes_to)
										return [true, dateAtDayMinutes(date, minutes_to), has_open_end];
									else
										return [false, dateAtDayMinutes(date, minutes_from + minutes_in_day)];
								}
							}}(minutes_from, minutes_to, timevar_string, timevar_add, has_open_end, is_point_in_time, point_in_time_period));
						}
					} else {
						selectors.time.push(function(date) { return [true]; });
					}

				} else if (matchTokens(tokens, at, 'number', '-', 'number')) { // "Mo 09-18" (Please don’t use this) -> "Mo 09:00-18:00".
					var minutes_from = tokens[at][0]   * 60;
					var minutes_to   = tokens[at+2][0] * 60;
					if (!done_with_warnings)
						parsing_warnings.push([nblock, at + 2,
							'Time range without minutes specified. Not very explicit! Please use this syntax instead e.g. "12:00-14:00".']);

					if (minutes_from >= minutes_in_day)
						throw formatWarnErrorMessage(nblock, at,
							'Time range starts outside of the current day');
					if (minutes_to < minutes_from)
						minutes_to += minutes_in_day;
					if (minutes_to > minutes_in_day * 2)
						throw formatWarnErrorMessage(nblock, at + 2,
							'Time spanning more than two midnights not supported');

					if (minutes_to > minutes_in_day) {
						selectors.time.push(function(minutes_from, minutes_to) { return function(date) {
							var ourminutes = date.getHours() * 60 + date.getMinutes();

							if (ourminutes < minutes_from)
								return [false, dateAtDayMinutes(date, minutes_from)];
							else
								return [true, dateAtDayMinutes(date, minutes_to)];
						}}(minutes_from, minutes_to));

						selectors.wraptime.push(function(minutes_from, minutes_to) { return function(date) {
							var ourminutes = date.getHours() * 60 + date.getMinutes();

							if (ourminutes < minutes_to)
								return [true, dateAtDayMinutes(date, minutes_to)];
							else
								return [false, undefined];
						}}(minutes_from, minutes_to - minutes_in_day));
					} else {
						selectors.time.push(function(minutes_from, minutes_to) { return function(date) {
							var ourminutes = date.getHours() * 60 + date.getMinutes();

							if (ourminutes < minutes_from)
								return [false, dateAtDayMinutes(date, minutes_from)];
							else if (ourminutes < minutes_to)
								return [true, dateAtDayMinutes(date, minutes_to), has_open_end];
							else
								return [false, dateAtDayMinutes(date, minutes_from + minutes_in_day)];
						}}(minutes_from, minutes_to));
					}

					at += 3;
				} else { // additional block
					if (matchTokens(tokens, at, '('))
						throw formatWarnErrorMessage(nblock, at, 'Missing variable time (e.g. sunrise) after: "' + tokens[at][1] + '"');
					if (matchTokens(tokens, at, 'number', 'timesep'))
						throw formatWarnErrorMessage(nblock, at+2, 'Missing minutes in time range after: "' + tokens[at+1][1] + '"');
					if (matchTokens(tokens, at, 'number'))
						throw formatWarnErrorMessage(nblock, at+2, 'Missing time seperator in time range after: "' + tokens[at][1] + '"');
					return [ at ];
				}

				if (!matchTokens(tokens, at, ','))
					break;
			}

			return at;
		}
		// }}}

		/* Get time in minutes from <hour>:<minute> (tokens). {{{
		 * Only used if throwing an error is wanted.
		 *
		 * :param tokens: List of token objects.
		 * :param nblock: Block number starting with 0.
		 * :param at: Position at which the time begins.
		 * :returns: Time in minutes.
		 */
		function getMinutesByHoursMinutes(tokens, nblock, at) {
			if (tokens[at+2][0] > 59)
				throw formatWarnErrorMessage(nblock, at+2,
						'Minutes are greater than 59.');
			return tokens[at][0] * 60 + tokens[at+2][0];
		}
		// }}}

		/* Get time in minutes from "(sunrise-01:30)" {{{
		 * Extract the added or subtracted time from "(sunrise-01:30)"
		 * returns time in minutes e.g. -90.
		 *
		 * :param tokens: List of token objects.
		 * :param at: Position where the specification for the point in time could be.
		 * :returns: Time in minutes on suggest, throws an exception otherwise.
		*/
		function parseTimevarCalc(tokens, at) {
			if (matchTokens(tokens, at+2, '+') || matchTokens(tokens, at+2, '-')) {
				if (matchTokens(tokens, at+3, 'number', 'timesep', 'number')) {
					if (matchTokens(tokens, at+6, ')')) {
						var add_or_subtract = tokens[at+2][0] == '+' ? '1' : '-1';
						var minutes = getMinutesByHoursMinutes(tokens, nblock, at+3) * add_or_subtract;
						if (minutes == 0)
							parsing_warnings.push([ nblock, at+5, 'Adding zero in a variable time calculation does not change the variable time.'
									+ ' Please omit the calculation (example: "12:00-sunset").' ]
								);
						return minutes;
					} else {
						error = [ at+6, '. Missing ")".'];
					}
				} else {
					error = [ at+5, ' (time).'];
				}
			} else {
				error = [ at+2, '. "+" or "-" expected.'];
			}

			if (error)
				throw formatWarnErrorMessage(nblock, error[0],
					'Calculcation with variable time is not in the right syntax' + error[1]);
		}
		// }}}

		/* Weekday range parser (Mo,We-Fr,Sa[1-2,-1],PH). {{{
		 *
		 * :param tokens: List of token objects.
		 * :param at: Position where the weekday tokens could be.
		 * :param selectors: Reference to selector object.
		 * :returns: Position at which the token does not belong to the selector anymore.
		 */
		function parseWeekdayRange(tokens, at, selectors) {
			for (; at < tokens.length; at++) {
				if (matchTokens(tokens, at, 'weekday', '[')) {
					// Conditional weekday (Mo[3])
					var numbers = [];

					// Get list of constraints
					var endat = parseNumRange(tokens, at+2, function(from, to, at) {

						// bad number
						if (from == 0 || from < -5 || from > 5)
							throw formatWarnErrorMessage(nblock, at,
								'Number between -5 and 5 (except 0) expected');

						if (from == to) {
							numbers.push(from);
						} else if (from < to) {
							for (var i = from; i <= to; i++) {
								// bad number
								if (i == 0 || i < -5 || i > 5)
									throw formatWarnErrorMessage(nblock, at+2,
										'Number between -5 and 5 (except 0) expected.');

								numbers.push(i);
							}
						} else {
							throw formatWarnErrorMessage(nblock, at+2,
								'Bad range: ' + from + '-' + to);
						}
					});

					if (!matchTokens(tokens, endat, ']'))
						throw formatWarnErrorMessage(nblock, endat, '"]" or more numbers expected.');

					var add_days = getMoveDays(tokens, endat+1, 6, 'constrained weekdays');
					week_stable = false;

					// Create selector for each list element.
					for (var nnumber = 0; nnumber < numbers.length; nnumber++) {

						selectors.weekday.push(function(weekday, number, add_days) { return function(date) {
							var date_num = getValueForDate(date, false); // Year not needed to distinguish.
							var start_of_this_month = new Date(date.getFullYear(), date.getMonth(), 1);
							var start_of_next_month = new Date(date.getFullYear(), date.getMonth() + 1, 1);

							var target_day_this_month;

							target_day_this_month = getDateForConstrainedWeekday(date.getFullYear(), date.getMonth(), weekday, [ number ]);

							var target_day_with_added_days_this_month = new Date(target_day_this_month.getFullYear(),
								target_day_this_month.getMonth(), target_day_this_month.getDate() + add_days);

							// The target day with added days can be before this month
							if (target_day_with_added_days_this_month.getTime() < start_of_this_month.getTime()) {
								// but in this case, the target day without the days added needs to be in this month
								if (target_day_this_month.getTime() >= start_of_this_month.getTime()) {
									// so we calculate it for the month
									// following this month and hope that the
									// target day will actually be this month.

									target_day_with_added_days_this_month = dateAtNextWeekday(
										new Date(date.getFullYear(), date.getMonth() + (number > 0 ? 0 : 1) + 1, 1), weekday);
									target_day_this_month.setDate(target_day_with_added_days_this_month.getDate()
										+ (number + (number > 0 ? -1 : 0)) * 7 + add_days);
								} else {
									// Calculated target day is not inside this month
									// therefore the specified weekday (e.g. fifth Sunday)
									// does not exist this month. Try it next month.
									return [false, start_of_next_month];
								}
							} else if (target_day_with_added_days_this_month.getTime() >= start_of_next_month.getTime()) {
								// The target day is in the next month. If the target day without the added days is not in this month
								if (target_day_this_month.getTime() >= start_of_next_month.getTime())
									return [false, start_of_next_month];
							}

							if (add_days > 0) {
								var target_day_with_added_moved_days_this_month = dateAtNextWeekday(
									new Date(date.getFullYear(), date.getMonth() + (number > 0 ? 0 : 1) -1, 1), weekday);
								target_day_with_added_moved_days_this_month.setDate(target_day_with_added_moved_days_this_month.getDate()
									+ (number + (number > 0 ? -1 : 0)) * 7 + add_days);

								if (date_num == getValueForDate(target_day_with_added_moved_days_this_month, false))
									return [true, dateAtDayMinutes(date, minutes_in_day)];
							} else if (add_days < 0) {
								var target_day_with_added_moved_days_this_month = dateAtNextWeekday(
									new Date(date.getFullYear(), date.getMonth() + (number > 0 ? 0 : 1) + 1, 1), weekday);
								target_day_with_added_moved_days_this_month.setDate(target_day_with_added_moved_days_this_month.getDate()
									+ (number + (number > 0 ? -1 : 0)) * 7 + add_days);

								if (target_day_with_added_moved_days_this_month.getTime() >= start_of_next_month.getTime()) {
									if (target_day_with_added_days_this_month.getTime() >= start_of_next_month.getTime())
										return [false, target_day_with_added_moved_days_this_month];
								} else {
									if (target_day_with_added_days_this_month.getTime() < start_of_next_month.getTime()
										&& getValueForDate(target_day_with_added_days_this_month, false) == date_num)
										return [true, dateAtDayMinutes(date, minutes_in_day)];

									target_day_with_added_days_this_month = target_day_with_added_moved_days_this_month;
								}
							}

							// we hit the target day
							if (date.getDate() == target_day_with_added_days_this_month.getDate()) {
								return [true, dateAtDayMinutes(date, minutes_in_day)];
							}

							// we're before target day
							if (date.getDate() < target_day_with_added_days_this_month.getDate()) {
								return [false, target_day_with_added_days_this_month];
							}

							// we're after target day, set check date to next month
							return [false, start_of_next_month];
						}}(tokens[at][0], numbers[nnumber], add_days[0]));
					}

					at = endat + 1 + add_days[1];
				} else if (matchTokens(tokens, at, 'weekday')) {
					// Single weekday (Mo) or weekday range (Mo-Fr)
					var is_range = matchTokens(tokens, at+1, '-', 'weekday');

					var weekday_from = tokens[at][0];
					var weekday_to = is_range ? tokens[at+2][0] : weekday_from;

					var inside = true;

					// handle reversed range
					if (weekday_to < weekday_from) {
						var tmp = weekday_to;
						weekday_to = weekday_from - 1;
						weekday_from = tmp + 1;
						inside = false;
					}

					if (weekday_to < weekday_from) { // handle full range
						selectors.weekday.push(function(date) { return [true]; });
						// Not needed. If there is no selector it automatically matches everything.
						// WRONG: This only works if there is no other selector in this selector group ...
					} else {
						selectors.weekday.push(function(weekday_from, weekday_to, inside) { return function(date) {
							var ourweekday = date.getDay();

							if (ourweekday < weekday_from || ourweekday > weekday_to) {
								return [!inside, dateAtNextWeekday(date, weekday_from)];
							} else {
								return [inside, dateAtNextWeekday(date, weekday_to + 1)];
							}
						}}(weekday_from, weekday_to, inside));
					}

					at += is_range ? 3 : 1;
				} else if (matchTokens(tokens, at, 'holiday')) {
					week_stable = false;
					return parseHoliday(tokens, at, selectors, true);
				} else {
					throw formatWarnErrorMessage(nblock, at, 'Unexpected token in weekday range: ' + tokens[at][1]);
				}

				if (!matchTokens(tokens, at, ','))
					break;
			}

			if (typeof used_subparsers['weekdays'] != 'object')
				used_subparsers['weekdays'] = [ at ];
			else
				used_subparsers['weekdays'].push(at);

			return at;
		}
		// }}}

		/* Get the number of days a date should be moved (if any). {{{
		 *
		 * :param tokens: List of token objects.
		 * :param at: Position where the date moving tokens could be.
		 * :param max_differ: Maximal number of days to move (could also be zero if there are no day move tokens).
		 * :returns: Array:
		 *			0. Days to add.
		 *			1. How many tokens.
		 */
		function getMoveDays(tokens, at, max_differ, name) {
			var add_days = [ 0, 0 ]; // [ 'days to add', 'how many tokens' ]
			add_days[0] = matchTokens(tokens, at, '+') || (matchTokens(tokens, at, '-') ? -1 : 0);
			if (add_days[0] != 0 && matchTokens(tokens, at+1, 'number', 'calcday')) {
				// continues with '+ 5 days' or something like that
				if (tokens[at+1][0] > max_differ)
					throw formatWarnErrorMessage(nblock, at+2,
						'There should be no reason to differ more than ' + max_differ + ' days from a ' + name + '. If so tell us …');
				add_days[0] *= tokens[at+1][0];
				if (add_days[0] == 0 && !done_with_warnings)
					parsing_warnings.push([ nblock, at+2, 'Adding 0 does not change the date. Please omit this.' ]);
				add_days[1] = 3;
			} else {
				add_days[0] = 0;
			}
			return add_days;
		}
		// }}}

		/* Holiday parser for public and school holidays (PH,SH) {{{
		 *
		 * :param tokens: List of token objects.
		 * :param at: Position where to start.
		 * :param selectors: Reference to selector object.
		 * :param push_to_weekday: Will push the selector into the weekday selector array which has the desired side effect of working in conjunction with the weekday selectors (either the holiday match or the weekday), which is the normal and expected behavior.
		 * :returns: Position at which the token does not belong to the selector anymore.
		 */
		function parseHoliday(tokens, at, selectors, push_to_weekday) {
			for (; at < tokens.length; at++) {
				if (matchTokens(tokens, at, 'holiday')) {
					if (tokens[at][0] == 'PH') {
						var applying_holidays = getMatchingHoliday(tokens[at][0]);

						// Only allow moving one day in the past or in the future.
						// This makes implementation easier because only one holiday is assumed to be moved to the next year.
						var add_days = getMoveDays(tokens, at+1, 1, 'public holiday');

						var selector = function(applying_holidays, add_days) { return function(date) {

							var holidays = getApplyingHolidaysForYear(applying_holidays, date.getFullYear(), add_days);
							// Needs to be calculated each time because of movable days.

							var date_num = getValueForDate(date, true);

							for (var i = 0; i < holidays.length; i++) {
								var next_holiday_date_num = getValueForDate(holidays[i][0], true);

								if (date_num < next_holiday_date_num) {

									if (add_days[0] > 0) {
										// Calculate the last holiday from previous year to tested against it.
										var holidays_last_year = getApplyingHolidaysForYear(applying_holidays, date.getFullYear() - 1, add_days);
										var last_holiday_last_year = holidays_last_year[holidays_last_year.length - 1];
										var last_holiday_last_year_num = getValueForDate(last_holiday_last_year[0], true);

										if (date_num < last_holiday_last_year_num ) {
											return [ false, last_holiday_last_year[0] ];
										} else if (date_num == last_holiday_last_year_num) {
											return [true, dateAtDayMinutes(last_holiday_last_year[0], minutes_in_day),
												'Day after ' +last_holiday_last_year[1] ];
										}
									}

									return [ false, holidays[i][0] ];
								} else if (date_num == next_holiday_date_num) {
									return [true, new Date(date.getFullYear(), date.getMonth(), date.getDate() + 1),
										(add_days[0] > 0 ? 'Day after ' : (add_days[0] < 0 ? 'Day before ' : '')) + holidays[i][1] ];
								}
							}

							if (add_days[0] < 0) {
								// Calculate the first holiday from next year to tested against it.
								var holidays_next_year = getApplyingHolidaysForYear(applying_holidays, date.getFullYear() + 1, add_days);
								var first_holidays_next_year = holidays_next_year[0];
								var first_holidays_next_year_num = getValueForDate(first_holidays_next_year[0], true);
								if (date_num == first_holidays_next_year_num) {
									return [true, dateAtDayMinutes(first_holidays_next_year[0], minutes_in_day),
										'Day before ' + first_holidays_next_year[1] ];
								}
							}

							// continue next year
							return [ false, new Date(holidays[0][0].getFullYear() + 1,
									holidays[0][0].getMonth(),
									holidays[0][0].getDate()) ];

						}}(applying_holidays, add_days);

						if (push_to_weekday)
							selectors.weekday.push(selector);
						else
							selectors.holiday.push(selector);

						at += 1 + add_days[1];
					} else if (tokens[at][0] == 'SH') {
						var applying_holidays = getMatchingHoliday(tokens[at][0]);

						var holidays = []; // needs to be sorted each time because of movable days

						var selector = function(applying_holidays) { return function(date) {
							var date_num = getValueForDate(date);

							// Iterate over holiday array containing the different holiday ranges.
							for (var i = 0; i < applying_holidays.length; i++) {

								var holiday = getSHForYear(applying_holidays[i], date.getFullYear());

								for (var h = 0; h < holiday.length; h+=4) {
									var holiday_to_plus = new Date(date.getFullYear(), holiday[2+h] - 1, holiday[3+h] + 1);
									var holiday_from = (holiday[0+h] - 1) * 100 + holiday[1+h];
									var holiday_to   = (holiday[2+h] - 1) * 100 + holiday[3+h];
									holiday_to_plus  = getValueForDate(holiday_to_plus);

									var holiday_ends_next_year = holiday_to < holiday_from;

									if (date_num < holiday_from) { // date is before selected holiday

										// check if we are in the holidays from the last year spanning into this year
										var last_year_holiday = getSHForYear(applying_holidays[applying_holidays.length - 1], date.getFullYear() - 1, false);
										if (typeof last_year_holiday != 'undefined') {
											var last_year_holiday_from = (last_year_holiday[last_year_holiday.length - 4] - 1) * 100
												+ last_year_holiday[last_year_holiday.length - 3]; // e.g. 1125
											var last_year_holiday_to   = (last_year_holiday[last_year_holiday.length - 2] - 1) * 100
												+ last_year_holiday[last_year_holiday.length - 1]; // e.g. 0005

											if (last_year_holiday_to < last_year_holiday_from && date_num < last_year_holiday_to)
												return [ true, new Date(date.getFullYear(),
													last_year_holiday[last_year_holiday.length - 2] - 1,
													last_year_holiday[last_year_holiday.length - 1] + 1),
													applying_holidays[applying_holidays.length - 1].name ];
											else
												return [ false, new Date(date.getFullYear(), holiday[0+h] - 1, holiday[1+h]) ];
										} else { // school holidays for last year are not defined.
											return [ false, new Date(date.getFullYear(), holiday[0+h] - 1, holiday[1+h]) ];
										}
									} else if (holiday_from <= date_num && (date_num < holiday_to_plus || holiday_ends_next_year)) {
										return [ true, new Date(date.getFullYear() + holiday_ends_next_year, holiday[2+h] - 1, holiday[3+h] + 1),
											applying_holidays[i].name ];
									} else if (holiday_to_plus == date_num) { // selected holiday end is equal to month and day
										if (h + 4 < holiday.length) { // next holiday is next date range of the same holidays
											h += 4;
											return [ false, new Date(date.getFullYear(), holiday[0+h] - 1, holiday[1+h]) ];
										} else {
											if (i + 1 == applying_holidays.length) { // last holidays are handled, continue all over again
												var holiday = getSHForYear(applying_holidays[0], date.getFullYear() + 1);
												return [ false, new Date(date.getFullYear() + !holiday_ends_next_year, holiday[0+h] - 1, holiday[1+h]) ];
											} else { // return the start of the next holidays
													var holiday = getSHForYear(applying_holidays[i+1], date.getFullYear());
													return [ false, new Date(date.getFullYear(), holiday[0] - 1, holiday[1]) ];
											}
										}
									}
								}
							}
							return [ false ];
						}}(applying_holidays);

						if (push_to_weekday)
							selectors.weekday.push(selector);
						else
							selectors.holiday.push(selector);
						at += 1;
					}
				} else if (matchTokens(tokens, at, 'weekday')) {
					return parseWeekdayRange(tokens, at, selectors);
				} else {
					throw formatWarnErrorMessage(nblock, at, 'Unexpected token (school holiday parser): ' + tokens[at][1]);
				}

				if (!matchTokens(tokens, at, ','))
					break;
			}

			return at;
		}

		// Helpers for holiday parsers {{{

		/* Returns a number for a date which can then be used to compare just the dates (without the time). {{{
		 * This is necessary because a selector could be called for the middle of the day and we need to tell if it matches that day.
		 * Example: Returns 20150015 for Jan 01 2015
		 *
		 * :param date: Date object.
		 * :param include_year: Boolean. If true include the year.
		 * :returns: Number for the date.
		 */
		function getValueForDate(date, include_year) {
			// Implicit because undefined evaluates to false.
			// include_year = typeof include_year != 'undefined' ? include_year : false;

			return (include_year ? date.getFullYear() * 10000 : 0) + date.getMonth() * 100 + date.getDate();
		}
		// }}}

		// return the school holiday definition e.g. [ 5, 25, /* to */ 6, 5 ],
		// for the specified year
		function getSHForYear(SH_hash, year, fatal) {
			if (typeof fatal == 'undefined')
				fatal = true;

			var holiday = SH_hash[year];
			if (typeof holiday == 'undefined') {
				holiday = SH_hash['default']; // applies for any year without explicit definition
				if (typeof holiday == 'undefined') {
					if (fatal) {
						throw 'School holiday ' + SH_hash.name + ' has no definition for the year ' + year + '.';
					} else {
						return undefined;
					}
				}
			}
			return holiday;
		}

		// Return closed holiday definition available.
		// First try to get the state, if missing get the country wide holidays
		// (which can be limited to some states).
		function getMatchingHoliday(type_of_holidays) {
			if (typeof location_cc != 'undefined') {
				if (holidays.hasOwnProperty(location_cc)) {
					if (typeof location_state != 'undefined') {
						if (holidays[location_cc][location_state]
								&& holidays[location_cc][location_state][type_of_holidays]) {
							// if holidays for the state are specified use it
							// and ignore lesser specific ones (for the country)
							return holidays[location_cc][location_state][type_of_holidays];
						} else if (holidays[location_cc][type_of_holidays]) {
							// holidays are only defined country wide
							matching_holiday = {}; // holidays in the country wide scope can be limited to certain states
							for (var holiday_name in holidays[location_cc][type_of_holidays]) {
								if (typeof holidays[location_cc][type_of_holidays][holiday_name][2] === 'object') {
									if (-1 != indexOf.call(holidays[location_cc][type_of_holidays][holiday_name][2], location_state))
										matching_holiday[holiday_name] = holidays[location_cc][type_of_holidays][holiday_name];
								} else {
									matching_holiday[holiday_name] = holidays[location_cc][type_of_holidays][holiday_name];
								}
							}
							if (Object.keys(matching_holiday).length == 0)
								throw 'There are no holidays ' + type_of_holidays + ' defined for country ' + location_cc + '.'
									+ ' Please add them: https://github.com/ypid/opening_hours.js ';
							return matching_holiday;
						} else {
							throw 'Holidays ' + type_of_holidays + ' are not defined for country ' + location_cc
								+ ' and state ' + location_state + '.'
								+ ' Please add them.';
						}
					}
				} else {
					throw 'No holidays are defined for country ' + location_cc + '. Please add them: https://github.com/ypid/opening_hours.js ';
				}
			} else { // we have no idea which holidays do apply because the country code was not provided
				throw 'Country code missing which is needed to select the correct holidays (see README how to provide it)'
			}
		}

		function getMovableEventsForYear(Y) {
			// calculate easter
			var C = Math.floor(Y/100);
			var N = Y - 19*Math.floor(Y/19);
			var K = Math.floor((C - 17)/25);
			var I = C - Math.floor(C/4) - Math.floor((C - K)/3) + 19*N + 15;
			I = I - 30*Math.floor((I/30));
			I = I - Math.floor(I/28)*(1 - Math.floor(I/28)*Math.floor(29/(I + 1))*Math.floor((21 - N)/11));
			var J = Y + Math.floor(Y/4) + I + 2 - C + Math.floor(C/4);
			J = J - 7*Math.floor(J/7);
			var L = I - J;
			var M = 3 + Math.floor((L + 40)/44);
			var D = L + 28 - 31*Math.floor(M/4);

			// calculate orthodox easter
			var oA = Y % 4;
			var oB = Y % 7;
			var oC = Y % 19;
			var oD = (19*oC + 15) % 30;
			var oE = (2*oA+4*oB - oD + 34) % 7;
			var oF = oD+oE

			if (oF < 9) {oDate = new Date(Y, 4-1, oF+4);}
			else {if ((oF+4)<31) {oDate = new Date(Y, 4-1, oF+4);}
			      else {oDate = new Date(Y, 5-1, oF-26);}}

			// calculate last Sunday in February
			var lastFebruaryDay = new Date(Y, 2, 0);
			var lastFebruarySunday = lastFebruaryDay.getDate() - lastFebruaryDay.getDay();

			// calculate Victoria Day. last Monday before or on May 24
			var may_24 = new Date(Y, 4, 24);
			var victoriaDay = 24  - ((6 + may_24.getDay()) % 7);

			// calculate Canada Day. July 1st unless 1st is on Sunday, then July 2.
			var july_1 = new Date(Y, 6, 1);
			var canadaDay = july_1.getDay() === 0 ? 2 : 1;

			// calculate first Monday for each month
			var firstMondays = {};
			for (var i = 0; i < 12; i++) {
				var first = new Date(Y, i, 1);
				var firstMonday = 1 + ((8 - first.getDay()) % 7);
				firstMondays[i] = firstMonday;
			};

			return {
				'firstFebruaryMonday': new Date(Y, 1, firstMondays[1]),
				'lastFebruarySunday': new Date(Y, 1, lastFebruarySunday),
				'easter': new Date(Y, M - 1, D),
				'victoriaDay': new Date(Y, 4, victoriaDay),
				'canadaDay': new Date(Y, 6, canadaDay),
				'firstAugustMonday': new Date(Y, 7, firstMondays[7]),
				'firstSeptemberMonday': new Date(Y, 8, firstMondays[8]),
				'firstOctoberMonday': new Date(Y, 9, firstMondays[9]),
				'orthodox easter' : oDate,
			};
		}

		function getApplyingHolidaysForYear(applying_holidays, year, add_days) {
			var movableDays = getMovableEventsForYear(year);

			var sorted_holidays = [];

			for (var holiday_name in applying_holidays) {
				if (typeof applying_holidays[holiday_name][0] == 'string') {
					var selected_movableDay = movableDays[applying_holidays[holiday_name][0]];
					if (!selected_movableDay)
						throw 'Movable day ' + applying_holidays[holiday_name][0] + ' can not not be calculated.'
							+ ' Please add the formula how to calculate it.';
					var next_holiday = new Date(selected_movableDay.getFullYear(),
							selected_movableDay.getMonth(),
							selected_movableDay.getDate()
							+ applying_holidays[holiday_name][1]
						);
					if (year != next_holiday.getFullYear())
						throw 'The movable day ' + applying_holidays[holiday_name][0] + ' plus '
							+ applying_holidays[holiday_name][1]
							+ ' days is not in the year of the movable day anymore. Currently not supported.';
				} else {
					var next_holiday = new Date(year,
							applying_holidays[holiday_name][0] - 1,
							applying_holidays[holiday_name][1]
						);
				}
				if (add_days[0])
					next_holiday.setDate(next_holiday.getDate() + add_days[0]);

				sorted_holidays.push([ next_holiday, holiday_name ]);
			}

			sorted_holidays = sorted_holidays.sort(function(a,b){
				if (a[0].getTime() < b[0].getTime()) return -1;
				if (a[0].getTime() > b[0].getTime()) return 1;
				return 0;
			});

			return sorted_holidays;
		}
		// }}}
		// }}}

		/* Year range parser (2013,2016-2018,2020/2). {{{
		 *
		 * :param tokens: List of token objects.
		 * :param at: Position where to start.
		 * :returns: Position at which the token does not belong to the selector anymore.
		 */
		function parseYearRange(tokens, at) {
			for (; at < tokens.length; at++) {
				if (matchTokens(tokens, at, 'year')) {
					var is_range = false, has_period = false;
					if (matchTokens(tokens, at+1, '-', 'year', '/', 'number')) {
						var is_range   = true;
						var has_period = true;
						var period = parseInt(tokens[at+4][0]);
						checkPeriod(at+4, period, 'year');
					} else {
						var is_range   = matchTokens(tokens, at+1, '-', 'year');
						var has_period = matchTokens(tokens, at+1, '/', 'number');
						if (has_period) {
							var period = parseInt(tokens[at+2][0]);
							checkPeriod(at+2, period, 'year', 'no_end_year');
						} else if (matchTokens(tokens, at+1, '+')) {
							var period = 1;
							has_period = 2;
						}
					}

					var year_from = parseInt(tokens[at][0]);
					// error checking {{{
						if (is_range && tokens[at+2][0] <= year_from) {
						// handle reversed range
						if (tokens[at+2][0] == year_from)
							throw formatWarnErrorMessage(nblock, at,
								'A year range in which the start year is equal to the end year does not make sense.'
								+ ' Please remove the end year. E.g. "' + year_from + ' May 23"');
						else
							throw formatWarnErrorMessage(nblock, at,
								'A year range in which the start year is greater than the end year does not make sense.'
								+ ' Please turn it over.');
						}
					// }}}

					selectors.year.push(function(tokens, at, year_from, is_range, has_period, period) { return function(date) {
						var ouryear = date.getFullYear();
						var year_to = is_range ? parseInt(tokens[at+2][0]) : year_from;

						if (ouryear < year_from ){
							return [false, new Date(year_from, 0, 1)];
						} else if (has_period) {
							if (year_from <= ouryear) {
								if (is_range && year_to < ouryear)
									return [false];
								if (period > 0) {
									if ((ouryear - year_from) % period == 0) {
										return [true, new Date(ouryear + 1, 0, 1)];
									} else {
										return [false, new Date(ouryear + period - 1, 0, 1)];
									}
								}
							}
						} else if (is_range) {
							if (ouryear <= year_to)
								return [true, new Date(year_to + 1, 0, 1)];
						} else if (ouryear == year_from) {
							return [true];
						}

						return [false];

					}}(tokens, at, year_from, is_range, has_period, period));

					at += 1 + (is_range ? 2 : 0) + (has_period ? (has_period == 2 ? 1 : 2) : 0);
				} else {
					throw formatWarnErrorMessage(nblock, at, 'Unexpected token in year range: ' + tokens[at][1]);
				}

				if (!matchTokens(tokens, at, ','))
					break;
			}

			if (typeof used_subparsers['year ranges'] != 'object')
				used_subparsers['year ranges'] = [ at ];
			else
				used_subparsers['year ranges'].push(at);

			return at;
		}
		// }}}

		/* Week range parser (week 11-20, week 1-53/2). {{{
		 *
		 * :param tokens: List of token objects.
		 * :param at: Position where to start.
		 * :returns: Position at which the token does not belong to the selector anymore.
		 */
		function parseWeekRange(tokens, at) {
			for (; at < tokens.length; at++) {
				if (matchTokens(tokens, at, 'number')) {
					var is_range = matchTokens(tokens, at+1, '-', 'number'), has_period = false;
					if (is_range) {
						has_period = matchTokens(tokens, at+3, '/', 'number');
						// if (week_stable) {
						// 	if (tokens[at][0] == 1 && tokens[at+2][0] >) // Maximum?
						// 		week_stable = true;
						// 	else
						// 		week_stable = false;
						// } else {
						// 	week_stable = false;
						// }
					}

					selectors.week.push(function(tokens, at, is_range, has_period) { return function(date) {
						var ourweek = Math.floor((date - dateAtWeek(date, 0)) / msec_in_week);

						var week_from = tokens[at][0] - 1;
						var week_to = is_range ? tokens[at+2][0] - 1 : week_from;

						var start_of_next_year = new Date(date.getFullYear() + 1, 0, 1);

						// before range
						if (ourweek < week_from)
							return [false, getMinDate(dateAtWeek(date, week_from), start_of_next_year)];

						// we're after range, set check date to next year
						if (ourweek > week_to)
							return [false, start_of_next_year];

						// we're in range
						var period;
						if (has_period) {
							var period = tokens[at+4][0];
							if (period > 1) {
								var in_period = (ourweek - week_from) % period == 0;
								if (in_period)
									return [true, getMinDate(dateAtWeek(date, ourweek + 1), start_of_next_year)];
								else
									return [false, getMinDate(dateAtWeek(date, ourweek + period - 1), start_of_next_year)];
							}
						}

						return [true, getMinDate(dateAtWeek(date, week_to + 1), start_of_next_year)];
					}}(tokens, at, is_range, has_period));

					at += 1 + (is_range ? 2 : 0) + (has_period ? 2 : 0);
				} else {
					throw formatWarnErrorMessage(nblock, at, 'Unexpected token in week range: ' + tokens[at][1]);
				}

				if (!matchTokens(tokens, at, ','))
					break;

				if (!matchTokens(tokens, at+1, 'number')) {
					at++; // we don‘t need the comma in parseGroup
					break;
				}
			}

			if (typeof used_subparsers['week ranges'] != 'object')
				used_subparsers['week ranges'] = [ at ];
			else
				used_subparsers['week ranges'].push;

			return at;
		}

		function dateAtWeek(date, week) {
			var tmpdate = new Date(date.getFullYear(), 0, 1);
			tmpdate.setDate(1 - (tmpdate.getDay() + 6) % 7 + week * 7); // start of week n where week starts on Monday
			return tmpdate;
		}

		function getMinDate(date /*, ...*/) {
			for (var i = 1; i < arguments.length; i++)
				if (arguments[i].getTime() < date.getTime())
					date = arguments[i];
			return date;
		}
		// }}}

		/* Month range parser (Jan,Feb-Mar). {{{
		 *
		 * :param tokens: List of token objects.
		 * :param at: Position where to start.
		 * :param push_to_monthday: Will push the selector into the monthday selector array which has the desired side effect of working in conjunction with the monthday selectors (either the month match or the monthday).
		 * :returns: Position at which the token does not belong to the selector anymore.
		 */
		function parseMonthRange(tokens, at, push_to_monthday) {
			for (; at < tokens.length; at++) {
				// Use parseMonthdayRange if '<month> <daynum>' and not '<month> <hour>:<minute>'
				if (matchTokens(tokens, at, 'month', 'number') && !matchTokens(tokens, at+2, 'timesep', 'number')) {
					return parseMonthdayRange(tokens, at, nblock, true);
				} else if (matchTokens(tokens, at, 'month')) {
					// Single month (Jan) or month range (Feb-Mar)
					var is_range = matchTokens(tokens, at+1, '-', 'month');

					if (is_range && week_stable) {
						var month_from = tokens[at][0];
						var month_to   = tokens[at+2][0];
						if (month_from == (month_to + 1) % 12)
							week_stable = true;
						else
							week_stable = false;
					} else {
						week_stable = false;
					}

					var selector = function(tokens, at, is_range) { return function(date) {
						var ourmonth = date.getMonth();
						var month_from = tokens[at][0];
						var month_to = is_range ? tokens[at+2][0] : month_from;

						var inside = true;

						// handle reversed range
						if (month_to < month_from) {
							var tmp = month_to;
							month_to = month_from - 1;
							month_from = tmp + 1;
							inside = false;
						}

						// handle full range
						if (month_to < month_from)
							return [!inside];

						if (ourmonth < month_from || ourmonth > month_to) {
							return [!inside, dateAtNextMonth(date, month_from)];
						} else {
							return [inside, dateAtNextMonth(date, month_to + 1)];
						}
					}}(tokens, at, is_range);

					if (push_to_monthday === true)
						selectors.monthday.push(selector);
					else
						selectors.month.push(selector);

					at += is_range ? 3 : 1;
				} else {
					throw formatWarnErrorMessage(nblock, at, 'Unexpected token in month range: ' + tokens[at][1]);
				}

				if (!matchTokens(tokens, at, ','))
					break;
			}

			if (typeof used_subparsers['months'] != 'object')
				used_subparsers['months'] = [ at ];
			else
				used_subparsers['months'].push(at);

			return at;
		}

		function dateAtNextMonth(date, month) {
			return new Date(date.getFullYear(), month < date.getMonth() ? month + 12 : month);
		}
		// }}}

		/* Month day range parser (Jan 26-31; Jan 26-Feb 26). {{{
		 *
		 * :param tokens: List of token objects.
		 * :param at: Position where to start.
		 * :param nblock: Block number starting with 0.
		 * :param push_to_month: Will push the selector into the month selector array which has the desired side effect of working in conjunction with the month selectors (either the month match or the monthday).
		 * :returns: Position at which the token does not belong to the selector anymore.
		 */
		function parseMonthdayRange(tokens, at, nblock, push_to_month) {
			for (; at < tokens.length; at++) {
				var has_year = [], has_month = [], has_event = [], has_calc = [], has_constrained_weekday = [], has_calc = [];
				has_year[0]  = matchTokens(tokens, at, 'year');
				has_month[0] = matchTokens(tokens, at+has_year[0], 'month', 'number');
				has_event[0] = matchTokens(tokens, at+has_year[0], 'event');
				if (has_event[0])
					has_calc[0] = getMoveDays(tokens, at+has_year[0]+1, 200, 'event like easter');

				if (matchTokens(tokens, at+has_year[0], 'month', 'weekday', '[')) {
					has_constrained_weekday[0] = getConstrainedWeekday(tokens, at+has_year[0]+3);
					has_calc[0] = getMoveDays(tokens, has_constrained_weekday[0][1], 6, 'constrained weekdays');
					var at_range_sep = has_constrained_weekday[0][1] + (typeof has_calc[0] != 'undefined' && has_calc[0][1] ? 3 : 0);
				} else {
					var at_range_sep = at+has_year[0]
						+ (has_event[0]
							? (typeof has_calc[0] != 'undefined' && has_calc[0][1] ? 4 : 1)
							: 2);
				}

				if ((has_month[0] || has_event[0] || has_constrained_weekday[0]) && matchTokens(tokens, at_range_sep, '-')) {
					has_year[1]  = matchTokens(tokens, at_range_sep+1, 'year');
					var at_sec_event_or_month = at_range_sep+1+has_year[1];
					has_month[1] = matchTokens(tokens, at_sec_event_or_month, 'month', 'number');
					if (!has_month[1]) {
						has_event[1] = matchTokens(tokens, at_sec_event_or_month, 'event');
						if (has_event[1]) {
							has_calc[1] = getMoveDays(tokens, at_sec_event_or_month+1, 366, 'event like easter');
						} else if (matchTokens(tokens, at_sec_event_or_month, 'month', 'weekday', '[')) {
							has_constrained_weekday[1] = getConstrainedWeekday(tokens, at_sec_event_or_month+3);
							has_calc[1] = getMoveDays(tokens, has_constrained_weekday[1][1], 6, 'constrained weekdays');
						}
					}
				}

				// monthday range like Jan 26-Feb 26 {{{
				if (has_year[0] == has_year[1] && (has_month[1] || has_event[1] || has_constrained_weekday[1])) {

					if (has_month[0])
						isValidDate(tokens[at+has_year[0]][0], tokens[at+has_year[0]+1][0], nblock, at+has_year[0]+1);
					if (has_month[1])
						isValidDate(tokens[at_sec_event_or_month][0], tokens[at_sec_event_or_month+1][0], nblock, at+has_year[0]+1);

					var selector = function(tokens, at, nblock, has_year, has_event, has_calc, at_sec_event_or_month, has_constrained_weekday) { return function(date) {
						var start_of_next_year = new Date(date.getFullYear() + 1, 0, 1);

						if (has_event[0]) {
							var movableDays = getMovableEventsForYear(has_year[0] ? parseInt(tokens[at][0]) : date.getFullYear());
							var from_date   = movableDays[tokens[at+has_year[0]][0]];

							if (typeof has_calc[0] != 'undefined' && has_calc[0][1]) {
								var from_year_before_calc = from_date.getFullYear();
								from_date.setDate(from_date.getDate() + has_calc[0][0]);
								if (from_year_before_calc != from_date.getFullYear())
									throw formatWarnErrorMessage(nblock, at+has_year[0]+has_calc[0][1]*3,
										'The movable day ' + tokens[at+has_year[0]][0] + ' plus ' + has_calc[0][0]
										+ ' days is not in the year of the movable day anymore. Currently not supported.');
							}
						} else if (has_constrained_weekday[0]) {
							var from_date = getDateForConstrainedWeekday((has_year[0] ? tokens[at][0] : date.getFullYear()), // year
								tokens[at+has_year[0]][0], // month
								tokens[at+has_year[0]+1][0], // weekday
								has_constrained_weekday[0],
								has_calc[0]);
							// var from_date_without_calc = getDateForConstrainedWeekday((has_year[0] ? tokens[at][0] : date.getFullYear()), // year
							// 	tokens[at+has_year[0]][0], // month
							// 	tokens[at+has_year[0]+1][0], // weekday
							// 	has_constrained_weekday[0],
							// 	[ 0, 0 ]);
							// 	if (from_date_without_calc.getFullYear() != from_date.getFullYear())
							// 		throw formatWarnErrorMessage(nblock, at+has_year[0]+has_calc[0][1],
							// 			'The constrained ' + weekdays[tokens[at+has_year[0]+1][0]] + ' plus ' + has_calc[0][0]
							// 			+ ' days is not in the year of the movable day anymore. Currently not supported.');
						} else {
							var from_date = new Date((has_year[0] ? tokens[at][0] : date.getFullYear()),
								tokens[at+has_year[0]][0], tokens[at+has_year[0]+1][0]);
						}

						if (has_event[1]) {
							var movableDays = getMovableEventsForYear(has_year[1]
										? parseInt(tokens[at_sec_event_or_month-1][0])
										: date.getFullYear());
							var to_date     = movableDays[tokens[at_sec_event_or_month][0]];

							if (typeof has_calc[1] != 'undefined' && has_calc[1][1]) {
								var to_year_before_calc = to_date.getFullYear();
								to_date.setDate(to_date.getDate() + has_calc[1][0]);
								if (to_year_before_calc != to_date.getFullYear())
									throw formatWarnErrorMessage(nblock, at_sec_event_or_month+has_calc[1][1],
										'The movable day ' + tokens[at_sec_event_or_month][0] + ' plus ' + has_calc[1][0]
										+ ' days is not in the year of the movable day anymore. Currently not supported.');
							}
						} else if (has_constrained_weekday[1]) {
							var to_date = getDateForConstrainedWeekday((has_year[1] ? tokens[at_sec_event_or_month-1][0] : date.getFullYear()), // year
								tokens[at_sec_event_or_month][0],   // month
								tokens[at_sec_event_or_month+1][0], // weekday
								has_constrained_weekday[1],
								has_calc[1]);
						} else {
							var to_date = new Date((has_year[1] ? tokens[at_sec_event_or_month-1][0] : date.getFullYear()),
								tokens[at_sec_event_or_month][0], tokens[at_sec_event_or_month+1][0] + 1);
						}

						var inside = true;

						if (to_date < from_date) {
							var tmp = to_date;
							to_date = from_date;
							from_date = tmp;
							inside = false;
						}

						if (date.getTime() < from_date.getTime()) {
							return [!inside, from_date];
						} else if (date.getTime() < to_date.getTime()) {
							return [inside, to_date];
						} else {
							if (has_year[0]) {
								return [!inside];
							} else {
								// // back matching, if from_date is moved to last year
								// var from_date_next_year = getDateForConstrainedWeekday(date.getFullYear() + 1, // year
								// 	tokens[at+has_year[0]][0], // month
								// 	tokens[at+has_year[0]+1][0], // weekday
								// 	has_constrained_weekday[0],
								// 	has_calc[0]);
								// if (date.getFullYear() == from_date_next_year.getFullYear()) {
								// 	if (date.getTime() < from_date_next_year.getTime()) {
								// 		return [!inside, from_date_next_year];
								// 	}
								// }

								return [!inside, start_of_next_year];
							}
						}
					}}(tokens, at, nblock, has_year, has_event, has_calc, at_sec_event_or_month, has_constrained_weekday);

					if (push_to_month === true)
						selectors.month.push(selector);
					else
						selectors.monthday.push(selector);

					at = (has_constrained_weekday[1]
							? has_constrained_weekday[1][1]
							: at_sec_event_or_month + (has_event[1] ? 1 : 2))
						+ (typeof has_calc[1] != 'undefined' ? has_calc[1][1] : 0);

					// }}}
					// Monthday range like Jan 26-31 {{{
				} else if (has_month[0]) {

					has_year = has_year[0];
					var year = tokens[at][0]; // Could be month if has no year. Tested later.
					var month = tokens[at+has_year][0];

					var first_round = true;

					do {
						var range_from = tokens[at+1 + has_year][0];
						var is_range = matchTokens(tokens, at+2+has_year, '-', 'number');
						var period = undefined;
						var range_to = tokens[at+has_year+(is_range ? 3 : 1)][0] + 1;
						if (is_range && matchTokens(tokens, at+has_year+4, '/', 'number')) {
							period = tokens[at+has_year+5][0];
							checkPeriod(at+has_year+5, period, 'day');
						}

						if (first_round) {
							var at_timesep_if_monthRange = at + has_year + 1 // at month number
								+ (is_range ? 2 : 0) + (period ? 2 : 0)
								+ !(is_range || period); // if not range nor has period, add one

							// Check for '<month> <timespan>'
							if (matchTokens(tokens, at_timesep_if_monthRange, 'timesep', 'number')
									&& (matchTokens(tokens, at_timesep_if_monthRange+2, '+')
										|| matchTokens(tokens, at_timesep_if_monthRange+2, '-')
										|| oh_mode != 0))
								return parseMonthRange(tokens, at);
						}

						// error checking {{{
						if (range_to < range_from)
							throw formatWarnErrorMessage(nblock, at+has_year+3,
									'Range in wrong order. From day is greater than to day.');
						isValidDate(month, range_from, nblock, at+1 + has_year);
						isValidDate(month, range_to - 1 /* added previously */,
								nblock, at+has_year+(is_range ? 3 : 1));
						// }}}

						var selector = function(year, has_year, month, range_from, range_to, period) { return function(date) {
							var start_of_next_year = new Date(date.getFullYear() + 1, 0, 1);

							var from_date = new Date(has_year ? year : date.getFullYear(),
								month, range_from);
							if (month == 1 && range_from != from_date.getDate()) // Only on leap years does this day exist.
								return [false]; // If day 29 does not exist,
												// then the date object adds one day to date
												// and this selector should not match.
							var to_date   = new Date(from_date.getFullYear(),
								month, range_to);
							if (month == 1 && is_range && range_to != to_date.getDate()) // Only on leap years does this day exist.
								return [false];

							if (date.getTime() < from_date.getTime())
								return [false, from_date];
							else if (date.getTime() >= to_date.getTime())
								return [false, start_of_next_year];
							else if (!period)
								return [true, to_date];

							var nday = Math.floor((date.getTime() - from_date.getTime()) / msec_in_day);
							var in_period = nday % period;

							if (in_period == 0)
								return [true, new Date(date.getFullYear(), date.getMonth(), date.getDate() + 1)];
							else
								return [false, new Date(date.getFullYear(), date.getMonth(), date.getDate() + period - in_period)];

						}}(year, has_year, month, range_from, range_to, period);

						if (push_to_month === true)
							selectors.month.push(selector);
						else
							selectors.monthday.push(selector);

						at += 2 + has_year + (is_range ? 2 : 0) + (period ? 2 : 0);

						first_round = false;
					}
					while (matchTokens(tokens, at, ',', 'number'))


					// }}}
					// Only event like easter {{{
				} else if (has_event[0]) {

					var selector = function(tokens, at, nblock, has_year, add_days) { return function(date) {

						// console.log('enter selector with date: ' + date);
						var movableDays = getMovableEventsForYear((has_year ? tokens[at][0] : date.getFullYear()));
						var event_date = movableDays[tokens[at+has_year][0]];
						if (!event_date)
							throw 'Movable day ' + tokens[at+has_year][0] + ' can not not be calculated.'
								+ ' Please add the formula how to calculate it.';

						if (add_days[0]) {
							event_date.setDate(event_date.getDate() + add_days[0]);
							if (date.getFullYear() != event_date.getFullYear())
								throw formatWarnErrorMessage(nblock, at+has_year+add_days[1], 'The movable day ' + tokens[at+has_year][0] + ' plus '
									+ add_days[0]
									+ ' days is not in the year of the movable day anymore. Currently not supported.');
						}

						if (date.getTime() < event_date.getTime())
							return [false, event_date];
						// else if (date.getTime() < event_date.getTime() + msec_in_day) // does not work because of daylight saving times
						else if (event_date.getMonth() * 100 + event_date.getDate() == date.getMonth() * 100 + date.getDate())
							return [true, new Date(date.getFullYear(), date.getMonth(), date.getDate() + 1)];
						else
							return [false, new Date(date.getFullYear() + 1, 0, 1)];

					}}(tokens, at, nblock, has_year[0], has_calc[0]);

					if (push_to_month === true)
						selectors.month.push(selector);
					else
						selectors.monthday.push(selector);

					at += has_year[0] + has_event[0] + (typeof has_calc[0][1] != 'undefined' && has_calc[0][1] ? 3 : 0);
					// }}}
				} else if (has_constrained_weekday[0]) {
					at = parseMonthRange(tokens, at);
				} else if (matchTokens(tokens, at, 'month')) {
					return parseMonthRange(tokens, at, true);
				} else {
					// throw 'Unexpected token in monthday range: "' + tokens[at] + '"';
					return at;
				}

				if (!matchTokens(tokens, at, ','))
					break;
			}

			if (typeof used_subparsers['monthday ranges'] != 'object')
				used_subparsers['monhday ranges'] = [ at ];
			else
				used_subparsers['monhday ranges'].push(at);

			return at;
		}
		// }}}

		/* Main selector traversal function (return state array for date). {{{
		 * Checks for given date which block and those which state and comment applies.
		 *
		 * :param date: Date object.
		 * :returns: Array:
		 *			0. resultstate: State: true for 'open', false for 'closed'.
		 *			1. changedate: Next change as date object.
		 *			2. unknown: true if state open is not sure.
		 *			3. comment: Comment which applies for this time range (from date to changedate).
		 *			4. match_block: Block number starting with 0 (nblock).
		 */
		this.getStatePair = function(date) {
			var resultstate = false;
			var changedate;
			var unknown = false;
			var comment;
			var match_block;

			var date_matching_blocks = [];

			for (var nblock = 0; nblock < blocks.length; nblock++) {
				var matching_date_block = true;
				// console.log(nblock, 'length',  blocks[nblock].date.length);

				// Try each date selector type
				for (var ndateselector = 0; ndateselector < blocks[nblock].date.length; ndateselector++) {
					var dateselectors = blocks[nblock].date[ndateselector];
					// console.log(nblock, ndateselector);

					var has_matching_selector = false;
					for (var datesel = 0; datesel < dateselectors.length; datesel++) {
						var res = dateselectors[datesel](date);
						if (res[0]) {
							has_matching_selector = true;

							if (typeof res[2] == 'string') { // holiday name
								comment = [ res[2] ];
							}

						}
						if (typeof changedate === 'undefined' || (typeof res[1] !== 'undefined' && res[1].getTime() < changedate.getTime()))
							changedate = res[1];
					}

					if (!has_matching_selector) {
						matching_date_block = false;
						// We can ignore other date selectors, as the state won't change
						// anyway until THIS selector matches (due to conjunction of date
						// selectors of different types).
						// This is also an optimization, if widest date selector types
						// are checked first.
						break;
					}

				}

				if (matching_date_block) {
					// The following lines implement date overwriting logic (e.g. for
					// "Mo-Fr 10:00-20:00; We 10:00-16:00", We block overrides Mo-Fr block.
					//
					// This is the only way to be consistent. I thought about ("22:00-02:00; Tu 12:00-14:00") letting Th override 22:00-02:00 partly:
					// Like: Th 00:00-02:00,12:00-14:00 but this would result in including 22:00-00:00 for Th which is probably not what you want.
					if (blocks[nblock].date.length > 0 && (blocks[nblock].meaning || blocks[nblock].unknown)
							&& !blocks[nblock].wrapped && !blocks[nblock].additional && !blocks[nblock].fallback) {
						// var old_date_matching_blocks = date_matching_blocks;
						date_matching_blocks = [];
						// for (var nblock = 0; nblock < old_date_matching_blocks.length; nblock++) {
						// 	if (!blocks[old_date_matching_blocks[nblock]].wrapped)
						// 		date_matching_blocks.push(nblock);
						// }
					}
					date_matching_blocks.push(nblock);
				}
			}

			block:
			for (var nblock = 0; nblock < date_matching_blocks.length; nblock++) {
				var block = date_matching_blocks[nblock];

				// console.log('Processing block ' + block + ':\t' + blocks[block].comment + '    with date', date,
				// 	'and', blocks[block].time.length, 'time selectors');

				// there is no time specified, state applies to the whole day
				if (blocks[block].time.length == 0) {
					// console.log('there is no time', date);
					if (!blocks[block].fallback || (blocks[block].fallback && !(resultstate || unknown))) {
						resultstate = blocks[block].meaning;
						unknown     = blocks[block].unknown;
						match_block = block;

						if (typeof blocks[block].comment != 'undefined')
							comment     = blocks[block].comment;
						else if (typeof comment == 'object') // holiday name
							comment = comment[0];

						if (blocks[block].fallback)
							break block; // fallback block matched, no need for checking the rest
					}
				}

				for (var timesel = 0; timesel < blocks[block].time.length; timesel++) {
					var res = blocks[block].time[timesel](date);

					// console.log('res:', res);
					if (res[0]) {
						if (!blocks[block].fallback || (blocks[block].fallback && !(resultstate || unknown))) {
							resultstate = blocks[block].meaning;
							unknown     = blocks[block].unknown;
							match_block = block;

							if (typeof blocks[block].comment == 'string') // only use comment if one is specified
								comment     = blocks[block].comment;
							else if (typeof comment == 'object') // holiday name
								comment = comment[0];
							else if (comment === 'Specified as open end. Closing time was guessed.')
								comment = blocks[block].comment;

							// open end
							if (typeof res[2] == 'boolean' && res[2] && (resultstate || unknown)) {
								if (typeof comment == 'undefined')
									comment = 'Specified as open end. Closing time was guessed.';
								resultstate = false;
								unknown     = true;
							}

							if (blocks[block].fallback) {
								if (typeof changedate === 'undefined' || (typeof res[1] !== 'undefined' && res[1] < changedate))
									changedate = res[1];

								// break block; // Fallback block matched, no need for checking the rest.
								// WRONG: What if 'off' is used after fallback block.
							}
						}
					}
					if (typeof changedate === 'undefined' || (typeof res[1] !== 'undefined' && res[1] < changedate))
						changedate = res[1];
				}
			}

			// console.log('changedate', changedate, resultstate, comment, match_block);
			return [ resultstate, changedate, unknown, comment, match_block ];
		}
		// }}}

		/* Generate prettified value based on tokens. {{{
		 *
		 * :param tokens: List of token objects.
		 * :param at: Position where to start.
		 * :param last_at: Position where to stop.
		 * :param conf: Configuration options.
		 * :param used_parseTimeRange: Boolean: True if time range parser was used for at till last_at.
		 * :returns: Prettified value.
		 */
		function prettifySelector(tokens, at, last_at, conf, used_parseTimeRange) {
			var value = '';
			var start_at = at;
			while (at < last_at) {
				if (matchTokens(tokens, at, 'weekday')) { // FIXME
					if (!conf.leave_weekday_sep_one_day_betw
						&& at - start_at > 1 && (matchTokens(tokens, at-1, ',') || matchTokens(tokens, at-1, '-'))
						&& matchTokens(tokens, at-2, 'weekday')
						&& tokens[at][0] == (tokens[at-2][0] + 1) % 7)  {
							value = value.substring(0, value.length - 1) + conf.sep_one_day_between;
					}
					value += weekdays[tokens[at][0]];
				} else if (at - start_at > 0 // e.g. '09:0' -> '09:00'
						&& used_parseTimeRange > 0
						&& matchTokens(tokens, at-1, 'timesep')
						&& matchTokens(tokens, at, 'number')) {
					value += (tokens[at][0] < 10 ? '0' : '') + tokens[at][0].toString();
				} else if (used_parseTimeRange > 0 // e.g. '9:00' -> ' 09:00'
						&& conf.leading_zero_hour
						&& at != tokens.length
						&& matchTokens(tokens, at, 'number')
						&& matchTokens(tokens, at+1, 'timesep')) {
					value += (
							tokens[at][0] < 10 ?
								(tokens[at][0] == 0 && conf.one_zero_if_hour_zero ?
								 '' : '0') :
								'') + tokens[at][0].toString();
				} else if (used_parseTimeRange > 0 // e.g. '9-18' -> '09:00-18:00'
						&& at + 2 < last_at
						&& matchTokens(tokens, at, 'number')
						&& matchTokens(tokens, at+1, '-')
						&& matchTokens(tokens, at+2, 'number')) {
					value += (tokens[at][0] < 10 ?
							(tokens[at][0] == 0 && conf.one_zero_if_hour_zero ? '' : '0')
							: '') + tokens[at][0].toString();
					value += ':00-'
						+ (tokens[at+2][0] < 10 ? '0' : '') + tokens[at+2][0].toString()
						+ ':00';
					at += 2;
				} else if (matchTokens(tokens, at, 'comment')) {
					value += '"' + tokens[at][0].toString() + '"';
				} else if (matchTokens(tokens, at, 'closed')) {
					value += (conf.leave_off_closed ? tokens[at][0] : conf.keyword_for_off_closed);
				} else if (at - start_at > 0 && matchTokens(tokens, at, 'number')
						&& (matchTokens(tokens, at-1, 'month')
						||  matchTokens(tokens, at-1, 'week')
						)) {
					value += ' ' + tokens[at][0];
				} else if (at - start_at > 0 && matchTokens(tokens, at, 'month')
						&& matchTokens(tokens, at-1, 'year')) {
					value += ' ' + months[[tokens[at][0]]];
				} else if (at - start_at > 0 && matchTokens(tokens, at, 'event')
						&& matchTokens(tokens, at-1, 'year')) {
					value += ' ' + tokens[at][0];
				} else if (matchTokens(tokens, at, 'month')) {
					value += months[[tokens[at][0]]];
					if (at + 1 < last_at && matchTokens(tokens, at+1, 'weekday'))
						value += ' ';
				} else if (at + 2 < last_at
						&& (matchTokens(tokens, at, '-') || matchTokens(tokens, at, '+'))
						&& matchTokens(tokens, at+1, 'number', 'calcday')) {
					value += ' ' + tokens[at][0] + tokens[at+1][0] + ' day' + (Math.abs(tokens[at+1][0]) == 1 ? '' : 's');
					at += 2;
				} else {
					// if (matchTokens(tokens, at, 'open') || matchTokens(tokens, at, 'unknown'))
					// 	value += ' ';

					value += tokens[at][0].toString();
				}
				at++;
			}
			return value + ' ';
		}
		// }}}

		//======================================================================
		// Public interface {{{
		// All functions below are considered public.
		//======================================================================

		//======================================================================
		// Iterator interface {{{
		//======================================================================
		this.getIterator = function(date) {
			return new function(oh) {
				if (typeof date === 'undefined')
					date = new Date();

				var prevstate = [ undefined, date, undefined, undefined, undefined ];
				var state = oh.getStatePair(date);

				this.setDate = function(date) {
					if (typeof date != 'object')
						throw 'Date as parameter needed.';

					prevstate = [ undefined, date, undefined, undefined, undefined ];
					state     = oh.getStatePair(date);
				}

				this.getDate = function() {
					return prevstate[1];
				}

				this.getState = function() {
					return state[0];
				}

				this.getUnknown = function() {
					return state[2];
				}

				this.getStateString = function(past) {
					return (state[0] ? 'open' : (state[2] ? 'unknown' : (past ? 'closed' : 'close')));
				}

				this.getComment = function() {
					return state[3];
				}

				this.getMatchingRule = function(user_conf) {
					if (typeof state[4] == 'undefined')
						return undefined;

					if (typeof user_conf != 'object')
						var user_conf = {};
					for (key in default_prettify_conf) {
						if (typeof user_conf[key] == 'undefined')
							user_conf[key] = default_prettify_conf[key];
					}

					var really_done_with_warnings = done_with_warnings; // getWarnings can be called later.
					done_with_warnings = true;
					prettified_value = '';
					var selectors = { // Not really needed. This whole thing is only necessary because of the token used for additional blocks.
						time: [], weekday: [], holiday: [], week: [], month: [], monthday: [], year: [], wraptime: [],

						fallback: false, // does not matter
						additional: false,
						meaning: true,
						unknown: false,
						comment: undefined,
					};

					// token block index used to build the selectors for this block.
					var token_block = blocks[state[4]].build_from_token_block;
					parseGroup(tokens[token_block[0]][0], token_block[1], selectors, state[4], user_conf);

					if (prettified_value[prettified_value.length - 1] == ',')
						prettified_value = prettified_value.substr(0, prettified_value.length - 1);

					done_with_warnings = really_done_with_warnings;

					return prettified_value;
				}

				this.advance = function(datelimit) {
					if (typeof datelimit === 'undefined')
						datelimit = new Date(prevstate[1].getTime() + msec_in_day * 366 * 5);
					else if (datelimit.getTime() <= prevstate[1].getTime())
						return false; // The limit for advance needs to be after the current time.

					do {
						// open range, we won't be able to advance
						if (typeof state[1] === 'undefined')
							return false;

						// console.log('\n' + 'previous check time:', prevstate[1]
						// 	+ ', current check time:',
						// 	// (state[1].getHours() < 10 ? '0' : '') + state[1].getHours() +
						// 	// ':'+(state[1].getMinutes() < 10 ? '0' : '')+ state[1].getMinutes(), state[1].getDate(),
						// 	state[1],
						// 	(state[0] ? 'open' : (state[2] ? 'unknown' : 'closed')) + ', comment:', state[3]);

						// We're going backwards or staying at place.
						// This always indicates coding error in a selector code.
						if (state[1].getTime() <= prevstate[1].getTime())
							throw 'Fatal: infinite loop in nextChange';

						// don't advance beyond limits (same as open range)
						if (state[1].getTime() >= datelimit.getTime())
							return false;

						// do advance
						prevstate = state;
						state = oh.getStatePair(prevstate[1]);
					} while (state[0] === prevstate[0] && state[2] === prevstate[2] && state[3] === prevstate[3]);
					return true;
				}
			}(this);
		}
		// }}}

		// Simple API {{{

		// Get parse warnings.
		// Returns an empty string if there are no warnings.
		this.getWarnings = function() {
			var it = this.getIterator();
			return getWarnings(it);
		}

		// Get a nicely formated value.
		this.prettifyValue = function(user_conf) {
			if (typeof user_conf != 'object')
				var user_conf = {};

			for (key in default_prettify_conf) {
				if (typeof user_conf[key] == 'undefined')
					user_conf[key] = default_prettify_conf[key];
			}

			var really_done_with_warnings = done_with_warnings; // getWarnings can be called later.
			done_with_warnings = true;

			prettified_value = '';
			for (var nblock = 0; nblock < tokens.length; nblock++) {
				if (tokens[nblock][0].length == 0) continue;
				// Block does contain nothing useful e.g. second block of '10:00-12:00;' (empty) which needs to be handled.

				if (nblock != 0)
					prettified_value += (tokens[nblock][1]
						?  user_conf.block_sep_string + '|| '
						: (user_conf.print_semicolon ? ';' : '') + user_conf.block_sep_string);

				var continue_at = 0;
				do {
					if (continue_at == tokens[nblock][0].length) break;
					// Block does contain nothing useful e.g. second block of '10:00-12:00,' (empty) which needs to be handled.

					var selectors = { // Not really needed. This whole thing is only necessary because of the token used for additional blocks.
						time: [], weekday: [], holiday: [], week: [], month: [], monthday: [], year: [], wraptime: [],

						fallback: tokens[nblock][1],
						additional: continue_at ? true : false,
						meaning: true,
						unknown: false,
						comment: undefined,
					};

					continue_at = parseGroup(tokens[nblock][0], continue_at, selectors, nblock, user_conf);

					if (typeof continue_at == 'object') {
						continue_at = continue_at[0];
						prettified_value += user_conf.block_sep_string;
					} else {
						continue_at = 0;
					}

				} while (continue_at)
			}

			done_with_warnings = really_done_with_warnings;

			return prettified_value;
		}

		// Check whether facility is `open' on the given date (or now).
		this.getState = function(date) {
			var it = this.getIterator(date);
			return it.getState();
		}

		// If the state of a amenity is conditional. Conditions can be expressed in comments.
		// True will only be returned if the state is false as the getState only
		// returns true if the amenity is really open. So you may want to check
		// the result of getUnknown if getState returned false.
		this.getUnknown = function(date) {
			var it = this.getIterator(date);
			return it.getUnknown();
		}

		// Return state string. Either 'open', 'unknown' or 'closed'.
		this.getStateString = function(date, past) {
			var it = this.getIterator(date);
			return it.getStateString(past);
		}

		// Returns the comment.
		// If no comment is specified this function will return undefined.
		this.getComment = function(date) {
			var it = this.getIterator(date);
			return it.getComment();
		}

		// Return the block which matched thus deterrents the current state.
		this.getMatchingRule = function(date) {
			var it = this.getIterator(date);
			return it.getMatchingRule();
		}

		// Returns time of next status change.
		this.getNextChange = function(date, maxdate) {
			var it = this.getIterator(date);
			if (!it.advance(maxdate))
				return undefined;
			return it.getDate();
		}

		// Checks whether open intervals are same for every week.
		this.isWeekStable = function() {
			return week_stable;
		}
		// }}}

		// High-level API {{{

		// return array of open intervals between two dates
		this.getOpenIntervals = function(from, to) {
			var res = [];

			var it = this.getIterator(from);

			if (it.getState() || it.getUnknown())
				res.push([from, undefined, it.getUnknown(), it.getComment()]);

			while (it.advance(to)) {
				if (it.getState() || it.getUnknown()) {
					if (res.length != 0 && typeof res[res.length - 1][1] == 'undefined') {
						// last state was also open or unknown
						res[res.length - 1][1] = it.getDate();
					}
					res.push([it.getDate(), undefined, it.getUnknown(), it.getComment()]);
				} else {
					if (res.length != 0 && typeof res[res.length - 1][1] == 'undefined') {
						// only use the first time as closing/change time and ignore closing times which might follow
						res[res.length - 1][1] = it.getDate();
					}
				}
			}

			if (res.length > 0 && typeof res[res.length - 1][1] === 'undefined')
				res[res.length - 1][1] = to;

			return res;
		}

		// return total number of milliseconds a facility is open within a given date range
		this.getOpenDuration = function(from, to) {
		// console.log('-----------');

			var open    = 0;
			var unknown = 0;

			var it = this.getIterator(from);
			var prevdate    = (it.getState() || it.getUnknown()) ? from : undefined;
			var prevstate   = it.getState();
			var prevunknown = it.getUnknown();

			while (it.advance(to)) {
				if (it.getState() || it.getUnknown()) {

					if (typeof prevdate !== 'undefined') {
						// last state was also open or unknown
						if (prevunknown) //
							unknown += it.getDate().getTime() - prevdate.getTime();
						else if (prevstate)
							open    += it.getDate().getTime() - prevdate.getTime();
					}

					prevdate    = it.getDate();
					prevstate   = it.getState();
					prevunknown = it.getUnknown();
					// console.log('if', prevdate, open / (1000 * 60 * 60), unknown / (1000 * 60 * 60));
				} else {
					// console.log('else', prevdate);
					if (typeof prevdate !== 'undefined') {
						if (prevunknown)
							unknown += it.getDate().getTime() - prevdate.getTime();
						else
							open    += it.getDate().getTime() - prevdate.getTime();
						prevdate = undefined;
					}
				}
			}

			if (typeof prevdate !== 'undefined') {
				if (prevunknown)
					unknown += to.getTime() - prevdate.getTime();
				else
					open    += to.getTime() - prevdate.getTime();
			}

			return [ open, unknown ];
		}
		// }}}
		// }}}
	}
}));
// vim: set ts=4 sw=4 tw=0 noet foldmarker={{{,}}} foldlevel=0 foldmethod=marker :
